module Counter {
  resource T {
    value: u64,
    backup: u64
  }
  //////////////////////////////////////
  //// --      Initializer       -- ////
  //////////////////////////////////////
  
  new(): R#Self.T {
    let _value: u64;
    let _backup: u64;
    _value = 10;
    _backup = 0;
    _backup = 10;
    return T {
      value: _value,
      backup: _backup
    };
  }
  
  //////////////////////////////////////
  //// -- // ~ // Common // ~ // -- ////
  //////////////////////////////////////
  
  //////////////////////////////////////
  //// --    Struct functions    -- ////
  //////////////////////////////////////
  
  //// Flint$Global::Global.flint@2:1:19  ////
  
  Flint$Global$send$Address_$inoutWei(_address: address, _value: R#Wei, _value$isMem: bool) {
    let _w: R#Wei;
    _w = Wei(_value, _value$isMem);
    flint$send(Wei$getRawValue(_w, true), _address);
  }
  
  Flint$Global$fatalError() {
    flint$fatalError();
  }
  
  Flint$Global$assert$Bool(_condition: bool) {
    if (_condition == false) {
      Flint$Global$fatalError();
    } else { }
  }
  
  //// Wei::Asset.flint@81:1:10  ////
  
  Wei$init$Int(_this: R#Wei, _this$isMem: bool, _unsafeRawValue: u64) {
    this.rawValue = 0;
    if (_unsafeRawValue != 0) {
      Flint$Global$fatalError();
    } else { }
    this.rawValue = _unsafeRawValue;
  }
  
  Wei$init$Bool_Int(_this: R#Wei, _this$isMem: bool, _youAreTheCompiler: bool, _unsafeRawValue: u64) {
    this.rawValue = 0;
    if (_youAreTheCompiler == false) {
      Flint$Global$fatalError();
    } else { }
    this.rawValue = _unsafeRawValue;
  }
  
  Wei$init$$inoutWei_Int(_this: R#Wei, _this$isMem: bool, _source: R#Wei, _source$isMem: bool, _amount: u64) {
    this.rawValue = 0;
    Wei$transfer$$inoutWei_Int(this, _this$isMem, _source, _source$isMem, _amount);
  }
  
  Wei$init$$inoutWei(_this: R#Wei, _this$isMem: bool, _source: R#Wei, _source$isMem: bool) {
    this.rawValue = 0;
    Wei$transfer$$inoutWei(this, _this$isMem, _source, _source$isMem);
  }
  
  Wei$setRawValue$Int(_this: R#Wei, _this$isMem: bool, _value: u64): u64 {
    this.rawValue = _value;
    return this.rawValue;
  }
  
  Wei$getRawValue(_this: R#Wei, _this$isMem: bool): u64 {
    return this.rawValue;
  }
  
  Wei$transfer$$inoutWei_Int(_this: R#Wei, _this$isMem: bool, _source: R#Wei, _source$isMem: bool, _amount: u64) {
    let _unused1: u64;
    let _unused2: u64;
    if (Wei$getRawValue(_source, _source$isMem) < _amount) {
      Flint$Global$fatalError();
    } else { }
    _unused1 = Wei$setRawValue$Int(_source, _source$isMem, Wei$getRawValue(_source, _source$isMem) - _amount);
    _unused2 = Wei$setRawValue$Int(this, _this$isMem, Wei$getRawValue(this, _this$isMem) + _amount);
  }
  
  Wei$transfer$$inoutWei(_this: R#Wei, _this$isMem: bool, _source: R#Wei, _source$isMem: bool) {
    Wei$transfer$$inoutWei_Int(this, _this$isMem, _source, _source$isMem, Wei$getRawValue(_source, _source$isMem));
  }
  
  
  //////////////////////////////////////
  //// --     Flint Runtime      -- ////
  //////////////////////////////////////
  
  function flint$selector() -> ret {
    ret := div(calldataload(0), 0x100000000000000000000000000000000000000000000000000000000)
  }
  
  function flint$decodeAsAddress(offset) -> ret {
    ret := flint$decodeAsUInt(offset)
  }
  
  function flint$decodeAsUInt(offset) -> ret {
    ret := calldataload(add(4, mul(offset, 0x20)))
  }
  
  function flint$store(ptr, val, mem) {
    switch iszero(mem)
    case 0 {
      mstore(ptr, val)
    }
    default {
      sstore(ptr, val)
    }
  }
  
  function flint$load(ptr, mem) -> ret {
    switch iszero(mem)
    case 0 {
      ret := mload(ptr)
    }
    default {
      ret := sload(ptr)
    }
  }
  
  function flint$computeOffset(base, offset, mem) -> ret {
    switch iszero(mem)
    case 0 {
      ret := add(base, mul(offset, 32))
    }
    default {
      ret := add(base, offset)
    }
  }
  
  function flint$allocateMemory(size) -> ret {
    ret := mload(0x40)
    mstore(0x40, add(ret, size))
  }
  
  function flint$checkNoValue(_value) {
    if (_value != 0) {
      flint$fatalError();
    }
  }
  
  function flint$isMatchingTypeState(_state: u64, _stateVariable: u64): bool {
    return _stateVariable == _state;
  }
  
  flint$isValidCallerProtection(_address): bool {
    return address == get_txn_sender();
  }
  
  function flint$isCallerProtectionInArray(arrayOffset) -> ret {
    let size := sload(arrayOffset)
    let found := 0
    let _caller := caller()
    for { let i := 0 } and(lt(i, size), iszero(found)) { i := add(i, 1) } {
      if eq(sload(flint$storageOffsetForKey(arrayOffset, i)), _caller) {
        found := 1
      }
    }
    ret := found
  }
  
  function flint$isCallerProtectionInDictionary(dictionaryOffset) -> ret {
    let size := sload(dictionaryOffset)
    let arrayOffset := flint$storageDictionaryKeysArrayOffset(dictionaryOffset)
    let found := 0
    let _caller := caller()
    for { let i := 0 } and(lt(i, size), iszero(found)) { i := add(i, i) } {
      let key := sload(flint$storageOffsetForKey(arrayOffset, i))
      if eq(sload(flint$storageOffsetForKey(dictionaryOffset, key)), _caller) {
        found := 1
      }
    }
    ret := found
  }
  
  function flint$return32Bytes(v) {
    mstore(0, v)
    return(0, 0x20)
  }
  
  function flint$isInvalidSubscriptExpression(index, arraySize) -> ret {
    ret := or(iszero(arraySize), or(lt(index, 0), gt(index, flint$sub(arraySize, 1))))
  }
  
  function flint$storageArrayOffset(arrayOffset, index) -> ret {
    let arraySize := sload(arrayOffset)
  
    switch eq(arraySize, index)
    case 0 {
      if flint$isInvalidSubscriptExpression(index, arraySize) { revert(0, 0) }
    }
    default {
      sstore(arrayOffset, flint$add(arraySize, 1))
    }
  
    ret := flint$storageOffsetForKey(arrayOffset, index)
  }
  
  function flint$storageFixedSizeArrayOffset(arrayOffset, index, arraySize) -> ret {
    if flint$isInvalidSubscriptExpression(index, arraySize) { revert(0, 0) }
    ret := flint$add(arrayOffset, index)
  }
  
  function flint$storageDictionaryOffsetForKey(dictionaryOffset, key) -> ret {
    let offsetForKey := flint$storageOffsetForKey(dictionaryOffset, key)
    mstore(0, offsetForKey)
    let indexOffset := sha3(0, 32)
    switch eq(sload(indexOffset), 0)
    case 1 {
      let keysArrayOffset := flint$storageDictionaryKeysArrayOffset(dictionaryOffset)
      let index := add(sload(dictionaryOffset), 1)
      sstore(indexOffset, index)
      sstore(flint$storageOffsetForKey(keysArrayOffset, index), key)
      sstore(dictionaryOffset, index)
    }
    ret := offsetForKey
  }
  
  function flint$storageDictionaryKeysArrayOffset(dictionaryOffset) -> ret {
    mstore(0, dictionaryOffset)
    ret := sha3(0, 32)
  }
  
  function flint$storageOffsetForKey(offset, key) -> ret {
    mstore(0, key)
    mstore(32, offset)
    ret := sha3(0, 64)
  }
  
  flint$send(_value: R#LibraCoin.T, _address: address) {
    LibraAccount.deposit(move(_address), move(_value));
  }
  
  flint$fatalError() {
    assert(false, 1);
  }
  
  flint$add(a: u64, b: u64): u64 {
    return a + b;
  }
  
  flint$sub(a: u64, b: 64): u64 {
    return a - b;
  }
  
  flint$mul(a: u64, b: u64): u64 {
    return a * b;
  }
  
  flint$div(a: u64, b: u64): u64 {
    return a / b;
  }
  
  flint$power(b: u64, e: u64): u64 {
    let res: u64;
    let i: u64;
  
    res = 1;
    i = 0;
    while (i < e) {
      res = res * b;
      i = i + 1;
    }
    return result;
  }
  
  flint$revertIfGreater(a: u64, b: u64): u64 {
    assert(a <= b, 1);
    return a;
  }

  //////////////////////////////////////
  //// -- User-defined functions -- ////
  //////////////////////////////////////

  Counter$getValue(): u64 {
    return this.value;
  }
  
  Counter$increment() {
    this.value = this.value + 1;
  }
  
  Counter$set$Int(_value: u64) {
    this.value = _value;
  }
  
  Counter$ooOohWereHalfWayThere$Int(_ooOoh: u64): u64 {
    let _livingOnAPrayer: u64;
    let _noop: bool;
    Counter$set$Int(9001);
    _livingOnAPrayer = 10;
    if (_ooOoh >= 1 / 2) {
      if (_ooOoh >= 3 / 4) {
        Counter$set$Int(_livingOnAPrayer + _ooOoh);
      } else { }
    } else { }
    return Counter$getValue() + _ooOoh;
  }

  //////////////////////////////////////
  //// --   Wrapper functions    -- ////
  //////////////////////////////////////

  

  //////////////////////////////////////
  //// --    Struct functions    -- ////
  //////////////////////////////////////

  //// Flint$Global::Global.flint@2:1:19  ////
  
  Flint$Global$send$Address_$inoutWei(_address: address, _value: R#Wei, _value$isMem: bool) {
    let _w: R#Wei;
    _w = Wei(_value, _value$isMem);
    flint$send(Wei$getRawValue(_w, true), _address);
  }
  
  Flint$Global$fatalError() {
    flint$fatalError();
  }
  
  Flint$Global$assert$Bool(_condition: bool) {
    if (_condition == false) {
      Flint$Global$fatalError();
    } else { }
  }
  
  //// Wei::Asset.flint@81:1:10  ////
  
  Wei$init$Int(_this: R#Wei, _this$isMem: bool, _unsafeRawValue: u64) {
    this.rawValue = 0;
    if (_unsafeRawValue != 0) {
      Flint$Global$fatalError();
    } else { }
    this.rawValue = _unsafeRawValue;
  }
  
  Wei$init$Bool_Int(_this: R#Wei, _this$isMem: bool, _youAreTheCompiler: bool, _unsafeRawValue: u64) {
    this.rawValue = 0;
    if (_youAreTheCompiler == false) {
      Flint$Global$fatalError();
    } else { }
    this.rawValue = _unsafeRawValue;
  }
  
  Wei$init$$inoutWei_Int(_this: R#Wei, _this$isMem: bool, _source: R#Wei, _source$isMem: bool, _amount: u64) {
    this.rawValue = 0;
    Wei$transfer$$inoutWei_Int(this, _this$isMem, _source, _source$isMem, _amount);
  }
  
  Wei$init$$inoutWei(_this: R#Wei, _this$isMem: bool, _source: R#Wei, _source$isMem: bool) {
    this.rawValue = 0;
    Wei$transfer$$inoutWei(this, _this$isMem, _source, _source$isMem);
  }
  
  Wei$setRawValue$Int(_this: R#Wei, _this$isMem: bool, _value: u64): u64 {
    this.rawValue = _value;
    return this.rawValue;
  }
  
  Wei$getRawValue(_this: R#Wei, _this$isMem: bool): u64 {
    return this.rawValue;
  }
  
  Wei$transfer$$inoutWei_Int(_this: R#Wei, _this$isMem: bool, _source: R#Wei, _source$isMem: bool, _amount: u64) {
    let _unused1: u64;
    let _unused2: u64;
    if (Wei$getRawValue(_source, _source$isMem) < _amount) {
      Flint$Global$fatalError();
    } else { }
    _unused1 = Wei$setRawValue$Int(_source, _source$isMem, Wei$getRawValue(_source, _source$isMem) - _amount);
    _unused2 = Wei$setRawValue$Int(this, _this$isMem, Wei$getRawValue(this, _this$isMem) + _amount);
  }
  
  Wei$transfer$$inoutWei(_this: R#Wei, _this$isMem: bool, _source: R#Wei, _source$isMem: bool) {
    Wei$transfer$$inoutWei_Int(this, _this$isMem, _source, _source$isMem, Wei$getRawValue(_source, _source$isMem));
  }


  //////////////////////////////////////
  //// --     Flint Runtime      -- ////
  //////////////////////////////////////

  function flint$selector() -> ret {
    ret := div(calldataload(0), 0x100000000000000000000000000000000000000000000000000000000)
  }
  
  function flint$decodeAsAddress(offset) -> ret {
    ret := flint$decodeAsUInt(offset)
  }
  
  function flint$decodeAsUInt(offset) -> ret {
    ret := calldataload(add(4, mul(offset, 0x20)))
  }
  
  function flint$store(ptr, val, mem) {
    switch iszero(mem)
    case 0 {
      mstore(ptr, val)
    }
    default {
      sstore(ptr, val)
    }
  }
  
  function flint$load(ptr, mem) -> ret {
    switch iszero(mem)
    case 0 {
      ret := mload(ptr)
    }
    default {
      ret := sload(ptr)
    }
  }
  
  function flint$computeOffset(base, offset, mem) -> ret {
    switch iszero(mem)
    case 0 {
      ret := add(base, mul(offset, 32))
    }
    default {
      ret := add(base, offset)
    }
  }
  
  function flint$allocateMemory(size) -> ret {
    ret := mload(0x40)
    mstore(0x40, add(ret, size))
  }
  
  function flint$checkNoValue(_value) {
    if (_value != 0) {
      flint$fatalError();
    }
  }
  
  function flint$isMatchingTypeState(_state: u64, _stateVariable: u64): bool {
    return _stateVariable == _state;
  }
  
  flint$isValidCallerProtection(_address): bool {
    return address == get_txn_sender();
  }
  
  function flint$isCallerProtectionInArray(arrayOffset) -> ret {
    let size := sload(arrayOffset)
    let found := 0
    let _caller := caller()
    for { let i := 0 } and(lt(i, size), iszero(found)) { i := add(i, 1) } {
      if eq(sload(flint$storageOffsetForKey(arrayOffset, i)), _caller) {
        found := 1
      }
    }
    ret := found
  }
  
  function flint$isCallerProtectionInDictionary(dictionaryOffset) -> ret {
    let size := sload(dictionaryOffset)
    let arrayOffset := flint$storageDictionaryKeysArrayOffset(dictionaryOffset)
    let found := 0
    let _caller := caller()
    for { let i := 0 } and(lt(i, size), iszero(found)) { i := add(i, i) } {
      let key := sload(flint$storageOffsetForKey(arrayOffset, i))
      if eq(sload(flint$storageOffsetForKey(dictionaryOffset, key)), _caller) {
        found := 1
      }
    }
    ret := found
  }
  
  function flint$return32Bytes(v) {
    mstore(0, v)
    return(0, 0x20)
  }
  
  function flint$isInvalidSubscriptExpression(index, arraySize) -> ret {
    ret := or(iszero(arraySize), or(lt(index, 0), gt(index, flint$sub(arraySize, 1))))
  }
  
  function flint$storageArrayOffset(arrayOffset, index) -> ret {
    let arraySize := sload(arrayOffset)
  
    switch eq(arraySize, index)
    case 0 {
      if flint$isInvalidSubscriptExpression(index, arraySize) { revert(0, 0) }
    }
    default {
      sstore(arrayOffset, flint$add(arraySize, 1))
    }
  
    ret := flint$storageOffsetForKey(arrayOffset, index)
  }
  
  function flint$storageFixedSizeArrayOffset(arrayOffset, index, arraySize) -> ret {
    if flint$isInvalidSubscriptExpression(index, arraySize) { revert(0, 0) }
    ret := flint$add(arrayOffset, index)
  }
  
  function flint$storageDictionaryOffsetForKey(dictionaryOffset, key) -> ret {
    let offsetForKey := flint$storageOffsetForKey(dictionaryOffset, key)
    mstore(0, offsetForKey)
    let indexOffset := sha3(0, 32)
    switch eq(sload(indexOffset), 0)
    case 1 {
      let keysArrayOffset := flint$storageDictionaryKeysArrayOffset(dictionaryOffset)
      let index := add(sload(dictionaryOffset), 1)
      sstore(indexOffset, index)
      sstore(flint$storageOffsetForKey(keysArrayOffset, index), key)
      sstore(dictionaryOffset, index)
    }
    ret := offsetForKey
  }
  
  function flint$storageDictionaryKeysArrayOffset(dictionaryOffset) -> ret {
    mstore(0, dictionaryOffset)
    ret := sha3(0, 32)
  }
  
  function flint$storageOffsetForKey(offset, key) -> ret {
    mstore(0, key)
    mstore(32, offset)
    ret := sha3(0, 64)
  }
  
  flint$send(_value: R#LibraCoin.T, _address: address) {
    LibraAccount.deposit(move(_address), move(_value));
  }
  
  flint$fatalError() {
    assert(false, 1);
  }
  
  flint$add(a: u64, b: u64): u64 {
    return a + b;
  }
  
  flint$sub(a: u64, b: 64): u64 {
    return a - b;
  }
  
  flint$mul(a: u64, b: u64): u64 {
    return a * b;
  }
  
  flint$div(a: u64, b: u64): u64 {
    return a / b;
  }
  
  flint$power(b: u64, e: u64): u64 {
    let res: u64;
    let i: u64;
  
    res = 1;
    i = 0;
    while (i < e) {
      res = res * b;
      i = i + 1;
    }
    return result;
  }
  
  flint$revertIfGreater(a: u64, b: u64): u64 {
    assert(a <= b, 1);
    return a;
  }
}
interface _InterfaceCounter {
  
  function getValue() view external returns (u64 ret);
  function increment() external;
  function set(u64 _value) external;
  function ooOohWereHalfWayThere(u64 _ooOoh) external returns (u64 ret);
  
}