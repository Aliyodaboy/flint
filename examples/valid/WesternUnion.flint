contract WesternUnion {
  // only manager can add customers
  let manager: Address

  var customers: [Address]
  var numCustomers: Int = 0
  var accounts: [Address: Wei]

  invariant (numCustomers == customers.size)
  invariant (numCustomers >= 0)
}


WesternUnion :: (any) {
  public init(manager: Address)
  // mutates (Wei.rawValue)
  {
    self.manager = manager
    self.customers = []
    self.accounts = [:]
  }
}

WesternUnion :: (manager) {
  public func addCustomer(customer: Address)
    mutates (customers, numCustomers)

    pre (arrayContains(customers, customer) == false)
    post (numCustomers == prev(numCustomers) + 1)
    post (customers[prev(numCustomers)] == customer && arrayEach(c, customers, c == prev(c) || c == customer) && arrayContains(customers, customer))
  {
    customers[numCustomers] = customer
    numCustomers += 1 //Issue if we don't increment numCustomers
  }
}


WesternUnion :: customer <- (customers) {
  @payable
  public func deposit(implicit amount: Wei, recipient: Address)
    mutates (accounts, Wei.rawValue)
    pre (arrayContains(customers, recipient))
    pre (dictContains(accounts, recipient))
    post (accounts[recipient].rawValue == (prev(accounts[recipient].rawValue) + prev(amount.rawValue)))
    post (forall (a, Address, (accounts[a] == prev(accounts[a]) || a == recipient)))
  {
    accounts[recipient].transfer(source: &amount)
  }



  public func withdraw()
    mutates (accounts, Wei.rawValue, customers, manager, numCustomers)
    pre (dictContains(accounts, customer))
    pre (arrayContains(customers, customer))

    post (accounts[customer].rawValue == 0)
    post (forall (a, Address, (dictContains(accounts,a) ==> (accounts[a] == prev(accounts[a]) || a == customer))))
  {
    send(customer, &accounts[customer])
  }
}
