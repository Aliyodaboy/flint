contract Test {
}

struct J {
  var s: S
  var ss: [Int: S]

  public init(s: inout S)
  {
    self.s = s
    self.ss = [:]
    let j: J = J(&s)
  }

  public init()
    mutates (S.i, S.is, S.j)
  {
    self.s = S()
    self.ss = [:]
  }
}

struct S {
  var i: Int
  var is: [Int]
  var j: Int = 0

  invariant (i > 0)


  public init()
    pre (1==1)
  {
    self.is = []
    i = 1
  }

  public func wow()
    mutates (is)
    pre(2 == 2)
  {
    is[0] = 0
    j = 1
  }
}

Test :: (any) {
  public init()
    pre(1==1)
  {
  }

  @payable
  public func t(implicit w: Wei)
    mutates (S.i, S.is, S.j, J.s, J.ss, Wei.rawValue)
  {
    let v: Int = w.getRawValue()
    let s: S = S()
    let i: Int = s.i

    let j: J = J(&s)
    let k: Int = j.ss[i+=1].is[1]
  }
}
