contract Marking {
  var lecturer: Address
  var markers: [Address]
  var numMarkers: Int = 0
  var grades: [Address: Int]

  invariant(numMarkers == markers.size)
  // invariant (forall(a, Address, dictContains(grades, a) ==> grades[a] >= 0))


//missing holistic
//numMarkers increase ==> call the addMarker
  // invariant (forall (m: Marking, i: Int) :: (m.numMarkers == i && next(m.numMarkers == i + 1) ==> m.lecturer.Calls(m.addMarker(_))))
// change in grade ==> exists marker calls assignGrade
  // invariant (forall (m: Marking) :: (next(change(grades)) ==> exists (e: External) :: (arrayContains(markers, e) && e.Calls(m.assignGrade(_, _)))))
}

Marking :: (any) {
  public init(lecturer: Address) {
    self.lecturer = lecturer
    self.markers = []
    self.grades = [:]
  }
}

Marking :: (lecturer) {
  public func addMarker(marker: Address)
    mutates (markers, numMarkers)
    pre (arrayContains(markers, marker) == false)
    post (numMarkers == prev(numMarkers) + 1)
    post (arrayContains(markers, marker))
    post (arrayEach(m, markers, m == prev(m) || m == marker))
  {
    markers[numMarkers] = marker
    numMarkers += 1
  }
}

Marking :: (markers) {
  public func assignGrade(student: Address, grade: Int)
    mutates (grades)
    post (forall (a, Address, (grades[a] == prev(grades[a]) || (a == student && grades[a] == grade))))
  {
    grades[student] = grade
  }
}

Marking :: caller <- (any) {
  public func getGrade() -> Int
  post (returning (r, r == grades[caller]))
  {
    return grades[caller]
  }


}
