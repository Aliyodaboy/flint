import AST
import Lexer
import Foundation

struct BoogieTranslator {
  // TODO: Need to parse contract invariants

  /*
  // invariants which need to hold on each function pre + post condition
  private var contractInvariants = [String]()
  */

  private let topLevelModule: TopLevelModule
  private let environment: Environment
  private var functionVariableDeclarations = [String: [BVariableDeclaration]]()
  private var currentFunction: String?
  private var currentContract: String?

  private var contractConstructorInitialisations = [String: [BStatement]]()

  public init(topLevelModule: TopLevelModule, environment: Environment) {
    self.topLevelModule = topLevelModule
    self.environment = environment
  }

  public mutating func translate() -> String {
    /* for everything defined in TLM, generate Boogie representation */
    // Generate AST and print
    return "// Generated by flintc\n \(generateAST())"
  }

  private mutating func generateAST() -> BTopLevelProgram {
    var declarations = [BTopLevelDeclaration]()

    for case .contractDeclaration(let contractDeclaration) in topLevelModule.declarations {
      declarations += process(contractDeclaration)
    }

    for case .structDeclaration(let structDeclaration) in topLevelModule.declarations {
      declarations += process(structDeclaration)
    }

    for case .enumDeclaration(let enumDeclaration) in topLevelModule.declarations {
      declarations += process(enumDeclaration)
    }

    for case .traitDeclaration(let traitDeclaration) in topLevelModule.declarations {
      declarations += process(traitDeclaration)
    }

    for case .contractBehaviorDeclaration(let contractBehaviorDeclaration) in topLevelModule.declarations {
      declarations += process(contractBehaviorDeclaration)
    }

    return BTopLevelProgram(declarations: declarations)
  }

  private mutating func process(_ contractDeclaration: ContractDeclaration) -> [BTopLevelDeclaration] {
    currentContract = contractDeclaration.identifier.name

    var declarations = [BTopLevelDeclaration]()
    for case .variableDeclaration(let variableDeclaration) in contractDeclaration.members {
      let name = variableDeclaration.identifier.name
      let type = convertType(variableDeclaration.type)
      declarations.append(BTopLevelDeclaration.variableDeclaration(
        BVariableDeclaration(name: name, type: type)))

      let assignedExpression = variableDeclaration.assignedExpression == nil
        ? defaultValue(type) : process(variableDeclaration.assignedExpression!)
      if contractConstructorInitialisations[currentContract!] == nil {
        contractConstructorInitialisations[currentContract!] = []
      }
      contractConstructorInitialisations[currentContract!]!.append(BStatement.assignment(BExpression.identifier(name),
                                                                      assignedExpression))
    }

    currentContract = nil
    return declarations
  }

  private func process(_ enumDeclaration: EnumDeclaration) -> [BTopLevelDeclaration] {
    // TODO:
    return []
  }

  private func process(_ traitDeclaration: TraitDeclaration) -> [BTopLevelDeclaration] {
    // TODO:
    return []
  }

  private func process(_ structDeclaration: StructDeclaration) -> [BTopLevelDeclaration] {
    /*
    for member in structDeclaration.members {
      switch member {
      case .variableDeclaration(let variableDeclaration):
      case .functionDeclaration...
      }
    }
    */
    // TODO:
    return []
  }

  private mutating func process(_ contractBehaviorDeclaration: ContractBehaviorDeclaration) -> [BTopLevelDeclaration] {
    currentContract = contractBehaviorDeclaration.contractIdentifier.name

    _ = contractBehaviorDeclaration.states // TODO: Type states
    _ = contractBehaviorDeclaration.callerProtections // TODO: Caller capabilities
    var declarations = [BTopLevelDeclaration]()

    for member in contractBehaviorDeclaration.members {
      switch member {
      case .specialDeclaration(let specialDeclaration):
        currentFunction =
          "\(specialDeclaration.signature.specialToken)_\(contractBehaviorDeclaration.contractIdentifier.name)"
        let body = specialDeclaration.body
        let parameters = specialDeclaration.signature.parameters
        let processedBody = body.flatMap({x in process(x)})

        // Constructor
        declarations.append(BTopLevelDeclaration.procedureDeclaration(BProcedureDeclaration(
          name: currentFunction!,
          returnType: nil,
          returnName: nil,
          parameters: parameters.map({x in process(x)}),
          preConditions: [], // TODO [BFirstOrderProperty]
          postConditions: [], // TODO [BFirstOrderProperty]
          modifies: [], // TODO [BModifiesDeclaration]
          statements: (processedBody + (specialDeclaration.isInit ?
                                        contractConstructorInitialisations[currentContract!] ?? [] : [])),
          variables: functionVariableDeclarations[currentFunction!] ?? []
          )))

        currentFunction = nil

      case .functionDeclaration(let functionDeclaration):
        currentFunction =
          "\(functionDeclaration.signature.identifier.name)_\(contractBehaviorDeclaration.contractIdentifier.name)"
        let body = functionDeclaration.body
        let parameters = functionDeclaration.signature.parameters
        let name = functionDeclaration.name
        let signature = functionDeclaration.signature

        declarations.append(BTopLevelDeclaration.procedureDeclaration(BProcedureDeclaration(
          name: "\(name)_\(contractBehaviorDeclaration.contractIdentifier.name)",
          returnType: signature.resultType == nil ? nil : convertType(signature.resultType!),
          returnName: signature.resultType == nil ? nil : "result", // TODO: check no conflicts with other variables
          parameters: parameters.map({x in process(x)}),
          preConditions: [], // TODO [BFirstOrderProperty]
          postConditions: [], // TODO [BFirstOrderProperty]
          modifies: [], // TODO [BModifiesDeclaration]
          statements: body.flatMap({x in process(x)}),
          variables: functionVariableDeclarations[currentFunction!] ?? []
          )))
        currentFunction = nil

      default:
        // TODO: Handle functionSignatureDeclaration case
        // TODO: Handle specialFunctionSignatureDeclaration case
        print("found declaration: \(member)")
      }
    }

    currentContract = nil
    return declarations
  }

  private func process(_ parameter: Parameter) -> BParameterDeclaration {
    return BParameterDeclaration(name: parameter.identifier.name,
                                 type: convertType(parameter.type))
  }

  private mutating func process(_ statement: Statement) -> [BStatement] {
    switch statement {
    case .expression(let expression):
      // Expresson can return statements -> assignments, or assertions..
      return process(expression)

    case .returnStatement(let returnStatement):
      var statements = [BStatement]()
      if let expression = returnStatement.expression {
         // TODO: Get result variable
        statements.append(BStatement.assignment(BExpression.identifier("result"), process(expression)))
      }
      statements.append(BStatement.returnStatement)
      return statements

    case .becomeStatement(let becomeStatement):
      // TODO: set state variable
      return []

    case .ifStatement(let ifStatement):
      return [BStatement.ifStatement(BIfStatement(condition: process(ifStatement.condition),
                                                  trueCase: ifStatement.body.flatMap({x in process(x)}),
                                                  falseCase: ifStatement.elseBody.flatMap({x in process(x)})))]

    case .forStatement(let forStatement):
      // TODO: Variable declared here
      // TODO: Append increment to end of body
      return [BStatement.whileStatement(BWhileStatement(condition: process(forStatement.iterable),
                                                  body: forStatement.body.flatMap({x in process(x)}),
                                                  invariants: []))] // TODO: invariants

    case .emitStatement(let emitStatement):
      // Ignore emit statements
      return []
    }
  }

  private mutating func process(_ expression: Expression) -> [BStatement] {
    switch expression {
    // TODO: Variable declarations are within binaryExpressions
      // Therefore, inspect binaryExpression to see if it's a binary Expression?
    // case .binaryExpression(let variableDeclaration):
    case .variableDeclaration(let variableDeclaration):
      let name = variableDeclaration.identifier.name
      let type = convertType(variableDeclaration.type)
      let assignedExpression = variableDeclaration.assignedExpression == nil
        ? defaultValue(type) : process(variableDeclaration.assignedExpression!)

      // Make sure to declare variable at start of function
      if functionVariableDeclarations[currentFunction!] == nil {
        functionVariableDeclarations[currentFunction!] = []
      }
      functionVariableDeclarations[currentFunction!]!.append(BVariableDeclaration(name: name, type: type))

      return [BStatement.assignment(BExpression.identifier(name), assignedExpression)]

    case .functionCall(let functionCall):
      //TODO: Implement -> asserts -> if external call.
      // TODO: If value was used in expression, need to create a variable and have it use it.
      // Create mapping from functionName to return variable?
      return []

    // TODO:
    //case arrayLiteral(ArrayLiteral)
    //case dictionaryLiteral(DictionaryLiteral)

    default:
      return [BStatement.expression(process(expression))]
    }
  }

  // TODO: This function is absolutely vile
  private mutating func process(_ expression: Expression) -> BExpression {
    switch expression {
    case .identifier(let identifier):
      return BExpression.identifier(identifier.name)

    case .binaryExpression(let binaryExpression):
      return process(binaryExpression)

    case .literal(let token):
      switch token.kind {
      case .literal(let literal):
          switch literal {
          case .boolean(let booleanLiteral):
            return BExpression.boolean(booleanLiteral == Token.Kind.BooleanLiteral.`true`)

          case .decimal(let decimalLiteral):
            switch decimalLiteral {
            case .integer(let i):
              return BExpression.integer(i)
            case .real(let b, let f):
              return BExpression.real(b, f)
            }

          case .string(let string):
            // TODO: Implement strings
            print("Not implemented translating strings")
            fatalError()
          case .address(let address):
            // TODO: Implement addresses
            print("Not implemented translating addresses")
            fatalError()
          }
      default:
        print("Not implemented handling other literals")
        fatalError()
      }

    case .rawAssembly:
      print("Not implemented translating raw assembly")
      fatalError()

      /*
      // TODO: Implement expressions
    case inoutExpression(InoutExpression)
    case `self`(Token)
    case bracketedExpression(BracketedExpression)
    case subscriptExpression(SubscriptExpression)
    case attemptExpression(AttemptExpression)
    case sequence([Expression])
    case range(RangeExpression)
      */

    default:
      return BExpression.integer(0)
    }
  }

  private mutating func process(_ binaryExpression: BinaryExpression) -> BExpression {
    let lhs: BExpression = process(binaryExpression.lhs)
    let rhs: BExpression = process(binaryExpression.rhs)
    switch binaryExpression.op.kind {
      /*
    case .at:
    case .arrow:
    case .leftArrow:
    case .comma:
    case .semicolon:
    case .doubleSlash:
    case .openAngledBracket:
    case .closeAngledBracket:

    case .plus:
    case .overflowingPlus:
    case .minus:
    case .overflowingMinus:
    case .times:
    case .overflowingTimes:
    case .power:
    case .divide:
    case .dot:
    case .dotdot:
    case .ampersand:
    case .bang:
    case .question:
`
    // Assignments
    case .equal:
    case .plusEqual:
    case .minusEqual:
    case .timesEqual:
    case .divideEqual:

    // Ranges
    case .halfOpenRange:
    case .closedRange:

    // Comparisons
    case .doubleEqual:
    case .notEqual:
    case .lessThanOrEqual:
    case .greaterThanOrEqual:
    case .or:
    case .and:
      */
    default:
      break
    }

    return BExpression.add(lhs, rhs)
  }

  private func convertType(_ type: Type) -> BType {
    return convertType(type.rawType)
  }

  private func convertType(_ type: RawType) -> BType {
    func convertBasicType(_ bType: RawType.BasicType) -> BType {
      switch bType {
      case .address: return BType.userDefined("Address")
      case .int: return BType.int
      case .bool: return BType.boolean
      default:
        print("not implemented conversion for basic type: \(type)")
        fatalError()
      }
    }

    func convertStdlibType(_ sType: RawType.StdlibType) -> BType {
      switch sType {
      case .wei:
        return BType.userDefined("Wei") //TODO: What about assets? Make this non-primitive?
      }
    }

    switch type {
    case .basicType(let basicType):
      return convertBasicType(basicType)
    case .stdlibType(let stdlibType):
      return convertStdlibType(stdlibType)
    case .dictionaryType(let keyType, let valueType):
      return BType.map(convertType(keyType), convertType(valueType))
    case .arrayType(let type):
      return BType.map(BType.int, convertType(type))
    default:
      print("not implemented conversion for type: \(type)")
      fatalError()
    }
  }

  private func defaultValue(_ type: BType) -> BExpression {
    switch type {
    case .int: return BExpression.integer(0)
    case .real: return BExpression.real(0, 0)
    case .boolean: return BExpression.boolean(false) // TODO: Is this the default bool value?

    default:
      return BExpression.integer(0)
    }
  }
}
