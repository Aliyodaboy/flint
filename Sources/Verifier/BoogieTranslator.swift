import AST
import Source
import Lexer
import Foundation

struct BoogieTranslator {
  private let topLevelModule: TopLevelModule
  private let environment: Environment
  // Variables declared in each function
  private var functionVariableDeclarations = [String: [BVariableDeclaration]]()
  // Procedure paramters
  private var functionParameters = [String: [BParameterDeclaration]]()
  // Name of procedure return variable
  private var functionReturnVariableName = [String: String]()
  // Global variables modified in each procedure
  private var functionGlobalModifications = [String: [String]]()
  // Empty Map Properties, for each type
  private var emptyMapProperties = [BType: (BFunctionDeclaration, BAxiomDeclaration, String)]()

  // Source location that each proof oligation corresponds to
  private var flintProofObligationSourceLocation = [Int: SourceLocation]()

  // Current behaviour member - function / special / signature declaration ..
  private var currentBehaviourMember: ContractBehaviorMember?
  // Current top level declaration - contract behaviour / trait / struct ..
  private var currentTLD: TopLevelDeclaration?

  // Name of state variable for each contract
  private var contractStateVariable = [String: String]()
  // Mapping of each state name, for each contract state variable
  private var contractStateVariableStates = [String: [String: Int]]()
  // Statements to be placed in the constructor of the contract
  private var contractConstructorInitialisations = [String: [BStatement]]()

  // Name of global variables in the contract
  private var contractGlobalVariables = [String: [String]]()
  // List of invariants for each contract
  private var contractInvariants = [String: [BProofObligation]]()

  public init(topLevelModule: TopLevelModule, environment: Environment) {
    self.topLevelModule = topLevelModule
    self.environment = environment
  }

  public mutating func translate() -> (String, [Int: SourceLocation]) {
    /* for everything defined in TLM, generate Boogie representation */
    // Generate AST and print
    let boogieCode = "// Generated by flintc\n \(generateAST())"
    return (boogieCode, generateFlint2BoogieMapping(code: boogieCode))
  }

  private mutating func generateAST() -> BTopLevelProgram {
    var declarations = [BTopLevelDeclaration]()

    for case .contractDeclaration(let contractDeclaration) in topLevelModule.declarations {
      self.currentTLD = .contractDeclaration(contractDeclaration)
      declarations += process(contractDeclaration)
      self.currentTLD = nil
    }

    for case .structDeclaration(let structDeclaration) in topLevelModule.declarations {
      self.currentTLD = .structDeclaration(structDeclaration)
      declarations += process(structDeclaration)
      self.currentTLD = nil
    }

    for case .enumDeclaration(let enumDeclaration) in topLevelModule.declarations {
      self.currentTLD = .enumDeclaration(enumDeclaration)
      declarations += process(enumDeclaration)
      self.currentTLD = nil
    }

    for case .traitDeclaration(let traitDeclaration) in topLevelModule.declarations {
      self.currentTLD = .traitDeclaration(traitDeclaration)
      declarations += process(traitDeclaration)
      self.currentTLD = nil
    }

    for case .contractBehaviorDeclaration(let contractBehaviorDeclaration) in topLevelModule.declarations {
      self.currentTLD = .contractBehaviorDeclaration(contractBehaviorDeclaration)
      declarations += process(contractBehaviorDeclaration)
      self.currentTLD = nil
    }

    let propertyDeclarations: [BTopLevelDeclaration]
      = emptyMapProperties.map({ arg in
                                     let (_, v) = arg
                                     let funcDec: BFunctionDeclaration = v.0
                                     let axDec: BAxiomDeclaration = v.1
                                     return [BTopLevelDeclaration.functionDeclaration(funcDec),
                                             BTopLevelDeclaration.axiomDeclaration(axDec)]
                                   }).reduce([], +)

    return BTopLevelProgram(declarations: propertyDeclarations + declarations)
  }

  private mutating func process(_ contractDeclaration: ContractDeclaration) -> [BTopLevelDeclaration] {
    var declarations = [BTopLevelDeclaration]()
    var contractGlobalVariables = [String]()

    for variableDeclaration in contractDeclaration.variableDeclarations {
      let name = translateGlobalIdentifierName(variableDeclaration.identifier.name)
      let type = convertType(variableDeclaration.type)

      // Some variables require shadow variables, eg dictionaries need an array of keys
      for bvariableDeclaration in generateVariables(variableDeclaration) {
        declarations.append(.variableDeclaration(bvariableDeclaration))
        contractGlobalVariables.append(bvariableDeclaration.name)
      }

      // Record assignment to put in constructor procedure
      let (assignedExpression, preStatements) = variableDeclaration.assignedExpression == nil
        ? (defaultValue(type), []) : process(variableDeclaration.assignedExpression!)
      if contractConstructorInitialisations[contractDeclaration.identifier.name] == nil {
        contractConstructorInitialisations[contractDeclaration.identifier.name] = []
      }
      contractConstructorInitialisations[contractDeclaration.identifier.name]! += preStatements
      contractConstructorInitialisations[contractDeclaration.identifier.name]!.append(
        .assignment(.identifier(name), assignedExpression)
      )
    }

    // TODO: Handle usage of += 1 and preStmts
    var invariantDeclarations = [BProofObligation]()
    for declaration in contractDeclaration.invariantDeclarations {
      //Invariants are turned into both pre and post conditions
      invariantDeclarations.append(BProofObligation(expression: process(declaration).0,
                                                    mark: declaration.sourceLocation.line,
                                                    obligationType: .preCondition))
      invariantDeclarations.append(BProofObligation(expression: process(declaration).0,
                                                    mark: declaration.sourceLocation.line,
                                                    obligationType: .postCondition))
      flintProofObligationSourceLocation[declaration.sourceLocation.line] = declaration.sourceLocation
    }
    contractInvariants[contractDeclaration.identifier.name] = invariantDeclarations

    let stateVariableName = generateStateVariable(contractDeclaration)
    contractStateVariable[contractDeclaration.identifier.name] = stateVariableName
    // Declare contract state variable
    declarations.append(.variableDeclaration(BVariableDeclaration(name: stateVariableName,
                                                                  rawName: stateVariableName,
                                                                  type: .int)))
    contractGlobalVariables.append(stateVariableName)

    contractStateVariableStates[contractDeclaration.identifier.name] = [String: Int]()
    for typeState in contractDeclaration.states {
      contractStateVariableStates[contractDeclaration.identifier.name]![typeState.name]
        = contractStateVariableStates[contractDeclaration.identifier.name]!.count
    }

    self.contractGlobalVariables[getCurrentTLDName()] = contractGlobalVariables

    return declarations
  }

  private func process(_ enumDeclaration: EnumDeclaration) -> [BTopLevelDeclaration] {
    // TODO:
    return []
  }

  private func process(_ traitDeclaration: TraitDeclaration) -> [BTopLevelDeclaration] {
    // TODO:
    return []
  }

  private func process(_ structDeclaration: StructDeclaration) -> [BTopLevelDeclaration] {
    /*
    for member in structDeclaration.members {
      switch member {
      case .variableDeclaration(let variableDeclaration):
      case .functionDeclaration...
      }
    }
    */
    // TODO:
    return []
  }

  private mutating func process(_ contractBehaviorDeclaration: ContractBehaviorDeclaration) -> [BTopLevelDeclaration] {
    // TODO: Use type states, to generate pre-conditions
    _ = contractBehaviorDeclaration.states
    // TODO: Use caller capabilities
    _ = contractBehaviorDeclaration.callerProtections
    var declarations = [BTopLevelDeclaration]()

    for member in contractBehaviorDeclaration.members {
      self.currentBehaviourMember = member
      switch member {
      case .specialDeclaration(let specialDeclaration):
        let currentFunctionName = getCurrentFunctionName()!
        let body = specialDeclaration.body
        let parameters = specialDeclaration.signature.parameters
        let processedBody = body.flatMap({x in process(x)})

        let bParameters = parameters.map({x in process(x)})
        setFunctionParameters(name: currentFunctionName, parameters: bParameters)

        // Constructor has no pre-conditions
        // - and constructor must setup invariant
        let postConditions = (contractInvariants[getCurrentTLDName()] ?? [])
          .filter({$0.obligationType != .preCondition})

        // Constructor
        declarations.append(.procedureDeclaration(BProcedureDeclaration(
          name: currentFunctionName,
          returnType: nil,
          returnName: nil,
          parameters: bParameters,
          prePostConditions: postConditions,
          //TODO: Only specify actually modified variables
          modifies: contractGlobalVariables[getCurrentTLDName()]!.map({ BModifiesDeclaration(variable: $0) }),
          statements: ((specialDeclaration.isInit ? contractConstructorInitialisations[getCurrentTLDName()] ?? [] : [])
                       + processedBody),
          variables: getFunctionVariableDeclarations(name: currentFunctionName)
          )))

      case .functionDeclaration(let functionDeclaration):
        let currentFunctionName = getCurrentFunctionName()!
        let body = functionDeclaration.body
        let parameters = functionDeclaration.signature.parameters
        //let name = functionDeclaration.name
        let signature = functionDeclaration.signature

        let bParameters = parameters.map({x in process(x)})
        setFunctionParameters(name: currentFunctionName, parameters: bParameters)

        var prePostConditions = [BProofObligation]()
        // TODO: Handle += operators and function calls in pre conditions
        for condition in signature.prePostConditions {
          switch condition {
          case .pre(let e):
            prePostConditions.append(BProofObligation(expression: process(e).0,
                                                      mark: e.sourceLocation.line,
                                                      obligationType: .preCondition))
            flintProofObligationSourceLocation[e.sourceLocation.line] = e.sourceLocation
          case .post(let e):
            prePostConditions.append(BProofObligation(expression: process(e).0,
                                                      mark: e.sourceLocation.line,
                                                      obligationType: .postCondition))
            flintProofObligationSourceLocation[e.sourceLocation.line] = e.sourceLocation
          }
        }

        // Procedure must hold invariant
        let invariants = contractInvariants[getCurrentTLDName()] ?? []
        prePostConditions += invariants

        declarations.append(.procedureDeclaration(BProcedureDeclaration(
          name: currentFunctionName,
          returnType: signature.resultType == nil ? nil : convertType(signature.resultType!),
          returnName: signature.resultType == nil ? nil : generateFunctionReturnVariable(),
          parameters: bParameters,
          prePostConditions: prePostConditions,
          modifies: [], // TODO [BModifiesDeclaration]
          statements: body.flatMap({x in process(x)}),
          variables: getFunctionVariableDeclarations(name: currentFunctionName)
          )))

      default:
        // TODO: Handle functionSignatureDeclaration case
        // TODO: Handle specialFunctionSignatureDeclaration case
        print("found declaration: \(member)")
      }
      currentBehaviourMember = nil
    }

    return declarations
  }

  private func process(_ parameter: Parameter) -> BParameterDeclaration {
    let name = parameter.identifier.name
    return BParameterDeclaration(name: translateIdentifierName(name),
                                 rawName: name,
                                 type: convertType(parameter.type))
  }

  private mutating func process(_ statement: Statement) -> [BStatement] {
    switch statement {
    case .expression(let expression):
      // Expresson can return statements -> assignments, or assertions..
      var (bExpression, statements) = process(expression)
      switch bExpression {
      case BExpression.identifier, BExpression.mapRead, BExpression.nop:
        break
      default:
        statements.append(.expression(bExpression))
      }
      return statements

    case .returnStatement(let returnStatement):
      var statements = [BStatement]()
      if let expression = returnStatement.expression {
        let (translatedExpr, preStatements) = process(expression)
        statements += preStatements
        statements.append(.assignment(.identifier(getFunctionReturnVariable()),
                                      translatedExpr))
      }
      statements.append(.returnStatement)
      return statements

    case .becomeStatement(let becomeStatement):
      let stateVariable = getStateVariable()
      let stateValue: Int
      switch becomeStatement.expression {
      case .identifier(let identifier):
         stateValue = getStateVariableValue(identifier.name)
      default:
        print("Unknown expression in becomeStatement \(becomeStatement.expression)")
        fatalError()
      }
      return [.assignment(.identifier(stateVariable), .integer(stateValue))]

    case .ifStatement(let ifStatement):
      let (condExpr, condStmt) = process(ifStatement.condition)
      return condStmt + [
        .ifStatement(BIfStatement(condition: condExpr,
                                  trueCase: ifStatement.body.flatMap({x in process(x)}),
                                  falseCase: ifStatement.elseBody.flatMap({x in process(x)}))
        )]

    case .forStatement(let forStatement):
      let (iterableExpr, condStmt) = process(forStatement.iterable)
      //TODO: Handle iterable. Move to next item -> depends on what we are incrementing

      // if iterable is:
      //  - array
      //    - iterate through
      //  - dict
      //    - shadow keys array
      //  - range
      //    - iterate through

      addCurrentFunctionVariableDeclaration(forStatement.variable)
      return condStmt + [
        .whileStatement(BWhileStatement(
          condition: iterableExpr,
          body: forStatement.body.flatMap({x in process(x)}),
          invariants: []) // TODO: invariants
        )]

    case .emitStatement:
      // Ignore emit statements
      return []
    }
  }

  private mutating func process(_ expression: Expression) -> (BExpression, [BStatement]) {
    switch expression {
    case .variableDeclaration(let variableDeclaration):
      let name = translateIdentifierName(variableDeclaration.identifier.name)

      // Some variable types require shadow variables, eg dictionaries (array of keys)
      for declaration in generateVariables(variableDeclaration) {
        addCurrentFunctionVariableDeclaration(declaration)
      }
      return (.identifier(name), [])

    case .functionCall(let functionCall):
      let rawFunctionName = functionCall.identifier.name
      var argumentsExpressions = [BExpression]()
      var argumentsStatements = [BStatement]()
      for arg in functionCall.arguments {
        let (expr, stmts) = process(arg.expression)
        argumentsExpressions.append(expr)
        argumentsStatements += stmts
      }

      // Special case to handle assert functions
      if rawFunctionName == "assert" {
        // assert that assert function call always has one argument
        assert (argumentsExpressions.count == 1)
        let flintLine = functionCall.identifier.sourceLocation.line
        flintProofObligationSourceLocation[flintLine] = functionCall.sourceLocation
        argumentsStatements.append(.assertStatement(BProofObligation(expression: argumentsExpressions[0],
                                                                     mark: flintLine,
                                                                     obligationType: .assertion)))
        return (.nop, argumentsStatements)
      }

      let functionName = translateGlobalIdentifierName(rawFunctionName)

      //TODO: Assert that contract invariant holds?
      if let returnType = getFunctionReturnBType(functionCall) {
        // Function returns a value
        let returnValueVariable = generateRandomIdentifier(prefix: "v_") // Variable to hold return value
        let returnValue = BExpression.identifier(returnValueVariable)
        let functionCall = BStatement.callProcedure([returnValueVariable],
                                                     functionName,
                                                     argumentsExpressions)
        addCurrentFunctionVariableDeclaration(BVariableDeclaration(name: returnValueVariable,
                                                                   rawName: returnValueVariable,
                                                                   type: returnType))
        argumentsStatements.append(functionCall)
        return (returnValue, argumentsStatements)
      } else {
        // Function doesn't return a value
        // Can assume can't be called as part of a nested expression, as it has no
        // return value -> Is this true? TODO - test
        argumentsStatements.append(.callProcedure([], functionName, argumentsExpressions))
        return (.nop, argumentsStatements)
      }

    case .identifier(let identifier):
      if let currentFunctionName = getCurrentFunctionName(),
         getFunctionVariableDeclarations(name: currentFunctionName)
           .filter({ $0.rawName == identifier.name })
           .count > 0 ||
          getFunctionParameters(name: currentFunctionName)
           .filter({ $0.rawName == identifier.name })
           .count > 0 {

        return (.identifier(translateIdentifierName(identifier.name)), [])
      }
      return (.identifier(translateGlobalIdentifierName(identifier.name)), [])

    case .binaryExpression(let binaryExpression):
      return process(binaryExpression)

    case .bracketedExpression(let bracketedExpression):
      return process(bracketedExpression.expression)

    case .subscriptExpression(let subscriptExpression):
      let (subExpr, subStmts) = process(subscriptExpression.baseExpression)
      let (indxExpr, indexStmts) = process(subscriptExpression.indexExpression)
      return (.mapRead(subExpr, indxExpr), subStmts + indexStmts)

    case .literal(let token):
      return (process(token), [])

    case .rawAssembly:
      print("Not implemented translating raw assembly")
      fatalError()

    case .`self`:
      return (.nop, [])

    case .arrayLiteral(let arrayLiteral):
      let literalVariableName = generateRandomIdentifier(prefix: "lit_")
      addCurrentFunctionVariableDeclaration(BVariableDeclaration(name: literalVariableName,
                                                                 rawName: literalVariableName,
                                                                 //TODO: Get actual type of array
                                                                 type: .map(.int, .int)))
      var assignmentStmts = [BStatement]()
      var counter = 0
      for expression in arrayLiteral.elements {
        let (bexpr, preStatements) = process(expression)
        assignmentStmts += preStatements
        assignmentStmts.append(.assignment(.mapRead(.identifier(literalVariableName), .integer(counter)), bexpr))
        counter += 1
      }
      return (.identifier(literalVariableName), assignmentStmts)

    case .dictionaryLiteral(let dictionaryLiteral):
      let literalVariableName = generateRandomIdentifier(prefix: "lit_")
      addCurrentFunctionVariableDeclaration(BVariableDeclaration(name: literalVariableName,
                                                                 rawName: literalVariableName,
                                                                 //TODO: Get actual type of array
                                                                 type: .map(.int, .int)))
      var assignmentStmts = [BStatement]()
      for entry in dictionaryLiteral.elements {
        let (bKeyExpr, bKeyPreStatements) = process(entry.key)
        let (bValueExpr, bValuePreStatements) = process(entry.value)
        assignmentStmts += bKeyPreStatements
        assignmentStmts += bValuePreStatements

        assignmentStmts.append(.assignment(.mapRead(.identifier(literalVariableName), bKeyExpr), bValueExpr))
      }
      return (.identifier(literalVariableName), assignmentStmts)

      // TODO: Implement expressions
    /*
    case .inoutExpression(let inoutExpression):
    case .attemptExpression(let attemptExpression):
    case .sequence(let expressions: [Expression]):
    case .range(let rangeExpression):
      */

    default:
      print("Not implemented translating \(expression.description)")
      fatalError()
    }
  }

  private func process(_ token: Token) -> BExpression {
    switch token.kind {
    case .literal(let literal):
      return process(literal)
    default:
      print("Not implemented handling other literals")
      fatalError()
    }
  }

  private func process(_ literal: Token.Kind.Literal) -> BExpression {
    switch literal {
    case .boolean(let booleanLiteral):
      return .boolean(booleanLiteral == Token.Kind.BooleanLiteral.`true`)

    case .decimal(let decimalLiteral):
      switch decimalLiteral {
      case .integer(let i):
        return .integer(i)
      case .real(let b, let f):
        return .real(b, f)
      }

    case .string:
      // TODO: Implement strings
      // Create const string for this literal -> const normalisedString: String;
      print("Not implemented translating strings")
      fatalError()
    case .address:
      // TODO: Implement addresses
      // Create const address -> for this literal -> const normalisedAddress: Address;
      print("Not implemented translating addresses")
      fatalError()
    }
  }

  private mutating func process(_ binaryExpression: BinaryExpression) -> (BExpression, [BStatement]) {
    let lhs = binaryExpression.lhs
    let rhs = binaryExpression.rhs
    let (rhsExpr, rhsStmts) = process(rhs)
    let (lhsExpr, lhsStmts) = process(lhs)

    switch binaryExpression.opToken {
    case .dot:
      switch lhs {
      case .`self`:
        // self.A, means get the A in the contract, not the local declaration

        switch rhs {
        case .identifier(let identifier):
          return (.identifier(translateGlobalIdentifierName(identifier.name)), [])
          // TODO: Implement for arrays
        default: break
        }
        print(rhs.description)
        fatalError()
        //return (rhsExpr, rhsStmts)

      // TODO: Implement for struct fields and methods (eg array size..)
      default:
        return (rhsExpr, rhsStmts)
      }

    case .equal:
      return (lhsExpr, lhsStmts + rhsStmts + [.assignment(lhsExpr, rhsExpr)])
    case .plusEqual:
      return (lhsExpr, lhsStmts + rhsStmts + [.assignment(lhsExpr, .add(lhsExpr, rhsExpr))])
    case .minusEqual:
      return (lhsExpr, lhsStmts + rhsStmts + [.assignment(lhsExpr, .subtract(lhsExpr, rhsExpr))])
    case .timesEqual:
      return (lhsExpr, lhsStmts + rhsStmts + [.assignment(lhsExpr, .multiply(lhsExpr, rhsExpr))])
    case .divideEqual:
      return (lhsExpr, lhsStmts + rhsStmts + [.assignment(lhsExpr, .divide(lhsExpr, rhsExpr))])

    case .plus:
      return (.add(lhsExpr, rhsExpr), lhsStmts + rhsStmts)
    case .minus:
      return (.subtract(lhsExpr, rhsExpr), lhsStmts + rhsStmts)
    case .times:
      return (.multiply(lhsExpr, rhsExpr), lhsStmts + rhsStmts)
    case .divide:
      return (.divide(lhsExpr, rhsExpr), lhsStmts + rhsStmts)

    //TODO Handle unsafe operators
    //case .overflowingPlus:
    //case .overflowingMinus:
    //case .overflowingTimes:

    //TODO: Handle power operator
    //case .power:

    // Comparisons
    case .doubleEqual:
      return (.equals(lhsExpr, rhsExpr), lhsStmts + rhsStmts)
    case .notEqual:
      return (.not(.equals(lhsExpr, rhsExpr)), lhsStmts + rhsStmts)
    case .openAngledBracket:
      return (.lessThan(lhsExpr, rhsExpr), lhsStmts + rhsStmts)
    case .closeAngledBracket:
      return (.greaterThan(lhsExpr, rhsExpr), lhsStmts + rhsStmts)
    case .lessThanOrEqual:
      return (.or(.lessThan(lhsExpr, rhsExpr), .equals(lhsExpr, rhsExpr)), lhsStmts + rhsStmts)
    case .greaterThanOrEqual:
      return (.not(.lessThan(lhsExpr, rhsExpr)), lhsStmts + rhsStmts)
    case .or:
      return (.or(lhsExpr, rhsExpr), lhsStmts + rhsStmts)
    case .and:
      return (.and(lhsExpr, rhsExpr), lhsStmts + rhsStmts)

      /*
      //TODO: Handle
    case .at:
    case .arrow:
    case .leftArrow:
    case .comma:
    case .semicolon:
    case .doubleSlash:
    case .dotdot:
    case .ampersand:
    case .bang:
    case .question:

    // Ranges
    case .halfOpenRange:
    case .closedRange:
      */
    default:
      print("Unknown binary operator used \(binaryExpression.opToken)")
      fatalError()
    }
  }

  private mutating func addCurrentFunctionVariableDeclaration(_ vDeclaration: VariableDeclaration) {
    let name = translateIdentifierName(vDeclaration.identifier.name)
    let type = convertType(vDeclaration.type)
    // Declared local expressions don't have assigned expressions
    assert(vDeclaration.assignedExpression == nil)

    addCurrentFunctionVariableDeclaration(BVariableDeclaration(name: name,
                                                               rawName: vDeclaration.identifier.name,
                                                               type: type))
  }

  private mutating func getFunctionParameters(name: String) -> [BParameterDeclaration] {
    if functionParameters[name] == nil {
      functionParameters[name] = []
    }
    return functionParameters[name]!
  }

  private mutating func setFunctionParameters(name: String, parameters: [BParameterDeclaration]) {
    functionParameters[name] = parameters
  }

  private mutating func getFunctionVariableDeclarations(name: String) -> [BVariableDeclaration] {
    if functionVariableDeclarations[name] == nil {
      functionVariableDeclarations[name] = []
    }
    return functionVariableDeclarations[name]!
  }

  private mutating func setFunctionVariableDeclarations(name: String, declarations: [BVariableDeclaration]) {
    functionVariableDeclarations[name] = declarations
  }

  private mutating func addCurrentFunctionVariableDeclaration(_ bvDeclaration: BVariableDeclaration) {
    if let functionName = getCurrentFunctionName() {
      var variableDeclarations = getFunctionVariableDeclarations(name: functionName)
      variableDeclarations.append(bvDeclaration)
      setFunctionVariableDeclarations(name: functionName, declarations: variableDeclarations)
    } else {
      print("Error cannot add variable declaration to function: \(bvDeclaration), not currently translating a function")
      fatalError()
    }
  }

  private func generateVariables(_ variableDeclaration: VariableDeclaration) -> [BVariableDeclaration] {
    // If currently in a function, then generate name with function in it
    // If in contractDeclaration, then generate name with only contract in it
    let name = getCurrentFunctionName() == nil ?
      translateGlobalIdentifierName(variableDeclaration.identifier.name)
      : translateIdentifierName(variableDeclaration.identifier.name)

    var declarations = [BVariableDeclaration]()
    let type = convertType(variableDeclaration.type)

    // TODO: Bounded array, then create array size variable
    switch type {
    case .map(let keyType, let valueType):
      declarations.append(BVariableDeclaration(name: "keys_\(name)",
                                               rawName: "keys_\(name)",
                                               type: .map(.int, keyType)))
      declarations.append(BVariableDeclaration(name: "values_\(name)",
                                               rawName: "values_\(name)",
                                               type: .map(.int, valueType)))
    default:
      break
    }

    declarations.append(BVariableDeclaration(name: name,
                                             rawName: variableDeclaration.identifier.name,
                                             type: type))
    return declarations
  }

  private func getStateVariable() -> String {
    return contractStateVariable[getCurrentTLDName()]!
  }

  private func getStateVariableValue(_ identifier: String) -> Int {
    return contractStateVariableStates[getCurrentTLDName()]![identifier]!
  }

  private func generateStateVariable(_ contractDeclaration: ContractDeclaration) -> String {
    let contractName = contractDeclaration.identifier.name
    return "stateVariable_\(contractName)"
  }

  private mutating func generateFunctionReturnVariable() -> String {
    if let functionName = getCurrentFunctionName() {
      let returnVariable = generateRandomIdentifier(prefix: "result_variable_\(functionName)_")
      functionReturnVariableName[functionName] = returnVariable
      return returnVariable
    }
    print("Cannot generate function return variable, not currently in a function")
    fatalError()
  }

  private func getFunctionReturnVariable() -> String {
    if let functionName = getCurrentFunctionName() {
      if let returnVariable = functionReturnVariableName[functionName] {
        return returnVariable
      }
      print("Could not find return variables for function \(functionName)")
      fatalError()
    }
    print("Could not find return variable not currently in a function")
    fatalError()
  }

  private func getFunctionReturnBType(_ functionCall: FunctionCall) -> BType? {
    //TODO: Get type of calling function
    /*
    let currentType = getCurrentTLDName() // TODO: This only works for functions within the same contract?
    if let scopeContext = getCurrentFunction().scopeContext {
      let callerProtections = getCurrentContractBehaviorDeclaration().callerProtections
      let typeStates = getCurrentContractBehaviorDeclaration().states
      switch environment.matchFunctionCall(functionCall,
                                           enclosingType: currentType,
                                           typeStates: typeStates,
                                           callerProtections: callerProtections,
                                           scopeContext: scopeContext) {

      case .matchedFunction(let functionInformation):
        return convertType(functionInformation.resultType)

      case .matchedGlobalFunction(let functionInformation):
        return convertType(functionInformation.resultType)

      case .failure:
        return nil

      default: break

      //case .matchedFunctionWithoutCaller(let callableInformations):
      //case .matchedInitializer(let specialInformation):
      //case .matchedFallback(let specialInformation):
      }
    }
    print("Cannot get scopeContext from current function")
    fatalError()
    */
    return BType.int
  }

  private func randomIdentifier(`prefix`: String = "i") -> String {
    return `prefix` + randomString(length: 10) // 10 random characters feels random enough
  }

  private func randomString(length: Int) -> String {
      let alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890"
      var s = ""
      for _ in 0..<length {
        let r = Int.random(in: 0..<alphabet.count)
        s += String(alphabet[alphabet.index(alphabet.startIndex, offsetBy: r)])
      }

    return s
  }

  private mutating func generateRandomIdentifier(prefix: String) -> String {
    if let functionName = getCurrentFunctionName() {
      let variableDeclarations = getFunctionVariableDeclarations(name: functionName)
      let returnIdentifier = randomIdentifier(prefix: prefix)

      for declaration in variableDeclarations
        where declaration.name == returnIdentifier {
        return generateRandomIdentifier(prefix: prefix)
      }
      return returnIdentifier
    }
    print("Could not generate function return value name, not currently in function")
    fatalError()
  }

  private func getCurrentFunctionName() -> String? {
    if let behaviourDeclarationMember = currentBehaviourMember {
      var functionName: String
      switch behaviourDeclarationMember {
      case .functionDeclaration(let functionDeclaration):
        functionName = functionDeclaration.signature.identifier.name
      case .specialDeclaration(let specialDeclaration):
        functionName = specialDeclaration.signature.specialToken.description
      case .functionSignatureDeclaration(let functionSignatureDeclaration):
        functionName = functionSignatureDeclaration.identifier.name
      case .specialSignatureDeclaration(let specialSignatureDeclaration):
        functionName = specialSignatureDeclaration.specialToken.description
      }

      return "\(functionName)_\(getCurrentTLDName())"
    }
    return nil
  }

  private func getCurrentContractBehaviorDeclaration() -> ContractBehaviorDeclaration {
    if let tld = currentTLD {
      switch tld {
      case .contractBehaviorDeclaration(let contractBehaviorDeclaration):
        return contractBehaviorDeclaration
      default:
        break
      }
    }
    print("Error cannot get current contract declaration - not in a contract")
    fatalError()
  }

  private func getCurrentFunction() -> FunctionDeclaration {
    if let behaviourDeclarationMember = currentBehaviourMember {
      switch behaviourDeclarationMember {
      case .functionDeclaration(let functionDeclaration):
        return functionDeclaration
      default:
        print("Error getting current function - not in a function: \(behaviourDeclarationMember.description)")
      }
    }
    print("Error getting current function - not in a current behaviour declaration")
    fatalError()
  }

  private func getCurrentTLDName() -> String {
    if let tld = currentTLD {
      switch tld {
      case .contractDeclaration(let contractDeclaration):
        return  contractDeclaration.identifier.name

      case .contractBehaviorDeclaration(let contractBehaviorDeclaration):
        return contractBehaviorDeclaration.contractIdentifier.name
      default:
        break

      /*
        TODO: Implement
      case .structDeclaration(let structDeclaration):
      case .enumDeclaration(let enumDeclaration):
      case .traitDeclaration(let traitDeclaration):
        */
      }
    }

    print("Error cannot get current contract name: not in a contract")
    fatalError()
  }

  private func translateIdentifierName(_ name: String) -> String {
    if let functionName = getCurrentFunctionName() {
      // Function name already has contract scope (eg. funcA_ContractA
      return name + "_\(functionName)"
    }
    print("Error cannot translate identifier: \(name), not translating contract")
    fatalError()
  }

  private func translateGlobalIdentifierName(_ name: String) -> String {
    return name + "_\(getCurrentTLDName())"
  }

  private func convertType(_ type: Type) -> BType {
    return convertType(type.rawType)
  }

  private func convertType(_ type: RawType) -> BType {
    func convertBasicType(_ bType: RawType.BasicType) -> BType {
      switch bType {
      case .address: return .userDefined("Address")
      case .int: return .int
      case .bool: return .boolean
      default:
        print("not implemented conversion for basic type: \(type)")
        fatalError()
      }
    }

    func convertStdlibType(_ sType: RawType.StdlibType) -> BType {
      switch sType {
      case .wei:
        return .userDefined("Wei") //TODO: What about assets? Make this non-primitive?
      }
    }

    switch type {
    case .basicType(let basicType):
      return convertBasicType(basicType)
    case .stdlibType(let stdlibType):
      return convertStdlibType(stdlibType)
    case .dictionaryType(let keyType, let valueType):
      return BType.map(convertType(keyType), convertType(valueType))
    case .arrayType(let type):
      return .map(.int, convertType(type))
    default:
      print("not implemented conversion for type: \(type)")
      fatalError()
    }
  }

  private mutating func defaultValue(_ type: BType) -> BExpression {
    switch type {
    case .int: return .integer(0)
    case .real: return .real(0, 0)
    case .boolean: return .boolean(false) // TODO: Is this the default bool value?
    case .userDefined:
      print("Can't translate default value for user defined type yet")
      fatalError()
    case .map(let t1, let t2):
      if let properties = emptyMapProperties[type] {
        return .functionApplication(properties.2, [])
      }

      let t2Default = defaultValue(t2)
      let emptyMapPropertyName = "Map_\(type.nameSafe).Empty"
      let emptyMapPropertyFunction: BFunctionDeclaration =
      BFunctionDeclaration(name: emptyMapPropertyName,
                           returnType: type,
                           returnName: "result",
                           parameters: [])
      let emptyMapPropertyAxiom: BAxiomDeclaration = BAxiomDeclaration(proposition:
       .quantified(.forall,
                   [BParameterDeclaration(name: "i", rawName: "i", type: t1)],
                   .equals(.mapRead(.functionApplication(emptyMapPropertyName, []), .identifier("i")), t2Default))
      )

      emptyMapProperties[type] = (emptyMapPropertyFunction, emptyMapPropertyAxiom, emptyMapPropertyName)

      return .functionApplication(emptyMapPropertyName, [])
    }
  }

  private func generateFlint2BoogieMapping(code: String) -> [Int: SourceLocation] {
    var mapping = [Int: SourceLocation]()

    let lines = code.trimmingCharacters(in: .whitespacesAndNewlines)
                               .components(separatedBy: "\n")
    var boogieLine = 1 // Boogie starts counting lines from 1
    for line in lines {
      // Pre increment because assert markers precede asserts and pre/post condits
      boogieLine += 1

      // Look for ASSERT markers
      let matches = line.groups(for: "// #MARKER# ([0-9]+)")
      if matches.count == 1 {
        // Extract line number
        mapping[boogieLine] = flintProofObligationSourceLocation[Int(matches[0][1])!]!
      }
    }
    return mapping
  }
}
