import AST
import Foundation

struct BoogieTranslator {
  // TODO: Need to parse contract invariants
  /*
  // invariants which need to hold on each function pre + post condition
  private var contractInvariants = [String]()
  */

  private let topLevelModule: TopLevelModule
  private let environment: Environment

  private var contractConstructorInitialisations = [BStatement]()

  public init(topLevelModule: TopLevelModule, environment: Environment) {
    self.topLevelModule = topLevelModule
    self.environment = environment
  }

  public mutating func translate() -> String {
    /* for everything defined in TLM, generate Boogie representation */
    // Generate AST and print
    return "// Generated by flintc\n \(generateAST())"
  }

  private mutating func generateAST() -> BTopLevelProgram {
    var declarations = [BTopLevelDeclaration]()

    for case .contractDeclaration(let contractDeclaration) in topLevelModule.declarations {
      declarations += process(contractDeclaration)
    }

    for case .structDeclaration(let structDeclaration) in topLevelModule.declarations {
      declarations += process(structDeclaration)
    }

    for case .enumDeclaration(let enumDeclaration) in topLevelModule.declarations {
      declarations += process(enumDeclaration)
    }

    for case .traitDeclaration(let traitDeclaration) in topLevelModule.declarations {
      declarations += process(traitDeclaration)
    }

    for case .contractBehaviorDeclaration(let contractBehaviorDeclaration) in topLevelModule.declarations {
      declarations += process(contractBehaviorDeclaration)
    }

    return BTopLevelProgram(declarations: declarations)
  }

  private mutating func process(_ contractDeclaration: ContractDeclaration) -> [BTopLevelDeclaration] {
    var declarations = [BTopLevelDeclaration]()

    for case .variableDeclaration(let variableDeclaration) in contractDeclaration.members {
      let name = variableDeclaration.identifier.name
      let type = convertType(variableDeclaration.type)
      declarations.append(BTopLevelDeclaration.variableDeclaration(
        BVariableDeclaration(name: name, type: type)))

      let assignedExpression = variableDeclaration.assignedExpression == nil
        ? defaultValue(type) : process(variableDeclaration.assignedExpression!)
      contractConstructorInitialisations.append(BStatement.assignment(BExpression.identifier(name),
                                                                      assignedExpression))
    }
    return declarations
  }

  private func process(_ enumDeclaration: EnumDeclaration) -> [BTopLevelDeclaration] {
    // TODO:
    return []
  }

  private func process(_ traitDeclaration: TraitDeclaration) -> [BTopLevelDeclaration] {
    // TODO:
    return []
  }

  private func process(_ structDeclaration: StructDeclaration) -> [BTopLevelDeclaration] {
    /*
    for member in structDeclaration.members {
      switch member {
      case .variableDeclaration(let variableDeclaration):
      case .functionDeclaration...
      }
    }
    */
    // TODO:
    return []
  }

  private func process(_ contractBehaviorDeclaration: ContractBehaviorDeclaration) -> [BTopLevelDeclaration] {
    _ = contractBehaviorDeclaration.states // TODO: Type states
    _ = contractBehaviorDeclaration.callerProtections // TODO: Caller capabilities
    var declarations = [BTopLevelDeclaration]()

    for member in contractBehaviorDeclaration.members {
      switch member {
      case .specialDeclaration(let specialDeclaration):
        let body = specialDeclaration.body
        let parameters = specialDeclaration.signature.parameters

        if specialDeclaration.isInit {
          // Constructor
          declarations.append(BTopLevelDeclaration.procedureDeclaration(BProcedureDeclaration(
            name: "init_\(contractBehaviorDeclaration.contractIdentifier.name)",
            returnType: nil,
            returnName: nil,
            parameters: parameters.map({x in process(x)}),
            preConditions: [], // TODO [BFirstOrderProperty]
            postConditions: [], // TODO [BFirstOrderProperty]
            modifies: [], // TODO [BModifiesDeclaration]
            statements: (body.flatMap({x in process(x)})) + contractConstructorInitialisations,
            variables: [] // TODO: local variables
            )))
        } else if specialDeclaration.isFallback {
          // fallback
          declarations.append(BTopLevelDeclaration.procedureDeclaration(BProcedureDeclaration(
            name: "fallback_\(contractBehaviorDeclaration.contractIdentifier.name)",
            returnType: nil,
            returnName: nil,
            parameters: parameters.map({x in process(x)}),
            preConditions: [], // TODO [BFirstOrderProperty]
            postConditions: [], // TODO [BFirstOrderProperty]
            modifies: [], // TODO [BModifiesDeclaration]
            statements: body.flatMap({x in process(x)}),
            variables: [] // TODO: local variables
            )))
        } else {
          // TODO: Handle error
          // Unknown type of special function declaration
          assert(false)
        }

      case .functionDeclaration(let functionDeclaration):
        let body = functionDeclaration.body
        let parameters = functionDeclaration.signature.parameters
        let name = functionDeclaration.name
        let signature = functionDeclaration.signature

        declarations.append(BTopLevelDeclaration.procedureDeclaration(BProcedureDeclaration(
          name: "\(name)_\(contractBehaviorDeclaration.contractIdentifier.name)",
          returnType: signature.resultType == nil ? nil : convertType(signature.resultType!),
          returnName: signature.resultType == nil ? nil : "result", // TODO: check no conflicts with other variables
          parameters: parameters.map({x in process(x)}),
          preConditions: [], // TODO [BFirstOrderProperty]
          postConditions: [], // TODO [BFirstOrderProperty]
          modifies: [], // TODO [BModifiesDeclaration]
          statements: body.flatMap({x in process(x)}),
          variables: [] // TODO: local variables
          )))

      default:
        // TODO: Handle functionSignatureDeclaration case
        // TODO: Handle specialFunctionSignatureDeclaration case
        print("found declaration: \(member)")
      }
    }
    return declarations
  }

  private func process(_ parameter: Parameter) -> BParameterDeclaration {
    return BParameterDeclaration(name: parameter.identifier.name,
                                 type: convertType(parameter.type))
  }

  private func process(_ statement: Statement) -> [BStatement] {
    switch statement {
    case .expression(let expression):
      return [BStatement.expression(process(expression))]
    case .returnStatement(let returnStatement):
      var statements = [BStatement]()
      if let expression = returnStatement.expression {
         // TODO: Get result variable
        statements.append(BStatement.assignment(BExpression.identifier("result"), process(expression)))
      }
      statements.append(BStatement.returnStatement)
      return statements
    case .becomeStatement(let becomeStatement):
      // TODO: set state variable
      return []
    case .ifStatement(let ifStatement):
      return [BStatement.ifStatement(BIfStatement(condition: process(ifStatement.condition),
                                                  trueCase: ifStatement.body.flatMap(process),
                                                  falseCase: ifStatement.elseBody.flatMap(process)))]
    case .forStatement(let forStatement):
      // TODO: Variable declared here
      // TODO: Append increment to end of body
      return [BStatement.whileStatement(BWhileStatement(condition: process(forStatement.iterable),
                                                  body: forStatement.body.flatMap(process),
                                                  invariants: []))] // TODO: invariants
    case .emitStatement(let emitStatement):
      // Ignore emit statements
      return []
    }
  }

  private func process(_ expression: Expression) -> BExpression {
    //TODO
    switch expression {
    case .identifier(let identifier):
      return BExpression.identifier(identifier.name)
    case .binaryExpression(let binaryExpression):
      return process(binaryExpression)
    default:
      return BExpression.number(0) // TODO: Implement remaining expressions
    }
  }

  private func process(_ binaryExpression: BinaryExpression) -> BExpression {
    let lhs = process(binaryExpression.lhs)
    let rhs = process(binaryExpression.rhs)
    switch binaryExpression.op.kind {
      /*
    case .at:
    case .arrow:
    case .leftArrow:
    case .comma:
    case .semicolon:
    case .doubleSlash:
    case .openAngledBracket:
    case .closeAngledBracket:

    case .plus:
    case .overflowingPlus:
    case .minus:
    case .overflowingMinus:
    case .times:
    case .overflowingTimes:
    case .power:
    case .divide:
    case .dot:
    case .dotdot:
    case .ampersand:
    case .bang:
    case .question:
`
    // Assignments
    case .equal:
    case .plusEqual:
    case .minusEqual:
    case .timesEqual:
    case .divideEqual:

    // Ranges
    case .halfOpenRange:
    case .closedRange:

    // Comparisons
    case .doubleEqual:
    case .notEqual:
    case .lessThanOrEqual:
    case .greaterThanOrEqual:
    case .or:
    case .and:
      */
    default:
      break
    }

    return BExpression.add(lhs, rhs)
  }

  private func convertType(_ type: Type) -> BType {
    func convertBasicType(_ bType: RawType.BasicType) -> BType {
      switch bType {
      case .address: return BType.userDefined("Address")
      case .int: return BType.int
      case .bool: return BType.boolean
      default:
        print("not implemented conversion for basic type: \(type)")
        assert(false)
      }
    }

    func convertStdlibType(_ sType: RawType.StdlibType) -> BType {
      switch sType {
      case .wei:
        return BType.userDefined("Wei") //TODO: What about assets? Make this non-primitive?
      }
    }

    switch type.rawType {
    case .basicType(let basicType):
      return convertBasicType(basicType)
    case .stdlibType(let stdlibType):
      return convertStdlibType(stdlibType)
    default:
      print("not implemented conversion for type: \(type)")
      assert(false)
    }
  }

  private func defaultValue(_ type: BType) -> BExpression {
    switch type {
    case .int: return BExpression.number(0)
    case .real: return BExpression.number(0) // TODO: Default real value => 0.0
    case .boolean: return BExpression.boolean(false) // TODO: Is this the default bool value?

    default:
      return BExpression.number(0)
    }
  }
}
