import AST
import Lexer
import Foundation

struct BoogieTranslator {
  // TODO: Need to parse contract invariants
  // TODO: Need to handle scoping issues -> local variables with same name as global ones

  /*
  // invariants which need to hold on each function pre + post condition
  private var contractInvariants = [String]()
  */

  private let topLevelModule: TopLevelModule
  private let environment: Environment
  private var functionVariableDeclarations = [String: [BVariableDeclaration]]()
  private var currentFunction: String?
  private var currentContract: String?
  private var contractStateVariable = [String: String]()
  private var contractStateVariableStates = [String: [String: Int]]()

  private var contractConstructorInitialisations = [String: [BStatement]]()

  public init(topLevelModule: TopLevelModule, environment: Environment) {
    self.topLevelModule = topLevelModule
    self.environment = environment
  }

  public mutating func translate() -> String {
    /* for everything defined in TLM, generate Boogie representation */
    // Generate AST and print
    return "// Generated by flintc\n \(generateAST())"
  }

  private mutating func generateAST() -> BTopLevelProgram {
    var declarations = [BTopLevelDeclaration]()

    for case .contractDeclaration(let contractDeclaration) in topLevelModule.declarations {
      declarations += process(contractDeclaration)
    }

    for case .structDeclaration(let structDeclaration) in topLevelModule.declarations {
      declarations += process(structDeclaration)
    }

    for case .enumDeclaration(let enumDeclaration) in topLevelModule.declarations {
      declarations += process(enumDeclaration)
    }

    for case .traitDeclaration(let traitDeclaration) in topLevelModule.declarations {
      declarations += process(traitDeclaration)
    }

    for case .contractBehaviorDeclaration(let contractBehaviorDeclaration) in topLevelModule.declarations {
      declarations += process(contractBehaviorDeclaration)
    }

    return BTopLevelProgram(declarations: declarations)
  }

  private mutating func process(_ contractDeclaration: ContractDeclaration) -> [BTopLevelDeclaration] {
    currentContract = contractDeclaration.identifier.name

    var declarations = [BTopLevelDeclaration]()
    for variableDeclaration in contractDeclaration.variableDeclarations {
      let name = variableDeclaration.identifier.name
      let type = convertType(variableDeclaration.type)
      declarations.append(.variableDeclaration(BVariableDeclaration(name: name,
                                                                    type: type)))
      // Record assignment to put in constructor procedure
      let assignedExpression = variableDeclaration.assignedExpression == nil
        ? defaultValue(type) : process(variableDeclaration.assignedExpression!)
      if contractConstructorInitialisations[currentContract!] == nil {
        contractConstructorInitialisations[currentContract!] = []
      }
      contractConstructorInitialisations[currentContract!]!.append(
        .assignment(.identifier(name), assignedExpression)
      )
    }

    let stateVariableName = generateStateVariable()
    contractStateVariable[currentContract!] = stateVariableName
    // Declare contract state variable
    declarations.append(.variableDeclaration(BVariableDeclaration(name: stateVariableName,
                                                                                      type: .int)))

    contractStateVariableStates[currentContract!] = [String: Int]()
    for typeState in contractDeclaration.states {
      contractStateVariableStates[currentContract!]![typeState.name]
        = contractStateVariableStates[currentContract!]!.count
    }

    currentContract = nil
    return declarations
  }

  private func process(_ enumDeclaration: EnumDeclaration) -> [BTopLevelDeclaration] {
    // TODO:
    return []
  }

  private func process(_ traitDeclaration: TraitDeclaration) -> [BTopLevelDeclaration] {
    // TODO:
    return []
  }

  private func process(_ structDeclaration: StructDeclaration) -> [BTopLevelDeclaration] {
    /*
    for member in structDeclaration.members {
      switch member {
      case .variableDeclaration(let variableDeclaration):
      case .functionDeclaration...
      }
    }
    */
    // TODO:
    return []
  }

  private mutating func process(_ contractBehaviorDeclaration: ContractBehaviorDeclaration) -> [BTopLevelDeclaration] {
    currentContract = contractBehaviorDeclaration.contractIdentifier.name

    // TODO: Use type states, to generate pre-conditions
    _ = contractBehaviorDeclaration.states
    // TODO: Use caller capabilities
    _ = contractBehaviorDeclaration.callerProtections
    var declarations = [BTopLevelDeclaration]()

    for member in contractBehaviorDeclaration.members {
      switch member {
      case .specialDeclaration(let specialDeclaration):
        currentFunction =
          "\(specialDeclaration.signature.specialToken)_\(contractBehaviorDeclaration.contractIdentifier.name)"
        let body = specialDeclaration.body
        let parameters = specialDeclaration.signature.parameters
        let processedBody = body.flatMap({x in process(x)})

        // Constructor
        declarations.append(.procedureDeclaration(BProcedureDeclaration(
          name: currentFunction!,
          returnType: nil,
          returnName: nil,
          parameters: parameters.map({x in process(x)}),
          preConditions: [], // TODO [BFirstOrderProperty]
          postConditions: [], // TODO [BFirstOrderProperty]
          modifies: [], // TODO [BModifiesDeclaration]
          statements: ((specialDeclaration.isInit ? contractConstructorInitialisations[currentContract!] ?? [] : [])
                       + processedBody),
          variables: functionVariableDeclarations[currentFunction!] ?? []
          )))

        currentFunction = nil

      case .functionDeclaration(let functionDeclaration):
        currentFunction =
          "\(functionDeclaration.signature.identifier.name)_\(contractBehaviorDeclaration.contractIdentifier.name)"
        let body = functionDeclaration.body
        let parameters = functionDeclaration.signature.parameters
        let name = functionDeclaration.name
        let signature = functionDeclaration.signature

        declarations.append(.procedureDeclaration(BProcedureDeclaration(
          name: "\(name)_\(contractBehaviorDeclaration.contractIdentifier.name)",
          returnType: signature.resultType == nil ? nil : convertType(signature.resultType!),
          returnName: signature.resultType == nil ? nil : "result", // TODO: check no conflicts with other variables
          parameters: parameters.map({x in process(x)}),
          preConditions: [], // TODO [BFirstOrderProperty]
          postConditions: [], // TODO [BFirstOrderProperty]
          modifies: [], // TODO [BModifiesDeclaration]
          statements: body.flatMap({x in process(x)}),
          variables: functionVariableDeclarations[currentFunction!] ?? []
          )))
        currentFunction = nil

      default:
        // TODO: Handle functionSignatureDeclaration case
        // TODO: Handle specialFunctionSignatureDeclaration case
        print("found declaration: \(member)")
      }
    }

    currentContract = nil
    return declarations
  }

  private func process(_ parameter: Parameter) -> BParameterDeclaration {
    return BParameterDeclaration(name: parameter.identifier.name,
                                 type: convertType(parameter.type))
  }

  private mutating func process(_ statement: Statement) -> [BStatement] {
    switch statement {
    case .expression(let expression):
      // Expresson can return statements -> assignments, or assertions..
      return process(expression)

    case .returnStatement(let returnStatement):
      var statements = [BStatement]()
      if let expression = returnStatement.expression {
         // TODO: Get result variable
        statements.append(.assignment(.identifier("result"), process(expression)))
      }
      statements.append(.returnStatement)
      return statements

    case .becomeStatement(let becomeStatement):
      let stateVariable = getStateVariable()
      let stateValue: Int
      switch becomeStatement.expression {
      case .identifier(let identifier):
         stateValue = getStateVariableValue(identifier.name)
      default:
        print("Unknown expression in becomeStatement \(becomeStatement.expression)")
        fatalError()
      }

      return [.assignment(.identifier(stateVariable), .integer(stateValue))]

    case .ifStatement(let ifStatement):
      return [.ifStatement(BIfStatement(condition: process(ifStatement.condition),
                                        trueCase: ifStatement.body.flatMap({x in process(x)}),
                                        falseCase: ifStatement.elseBody.flatMap({x in process(x)})))]

    case .forStatement(let forStatement):
      // TODO: Move to next item -> depends on what we are incrementing

      addCurrentFunctionVariableDeclaration(forStatement.variable)
      return [.whileStatement(BWhileStatement(condition: process(forStatement.iterable),
                                                body: forStatement.body.flatMap({x in process(x)}),
                                                invariants: []))] // TODO: invariants

    case .emitStatement(let emitStatement):
      // Ignore emit statements
      return []
    }
  }

  private mutating func process(_ expression: Expression) -> [BStatement] {
    switch expression {
      // Look for variable declaration and assignment
    case .binaryExpression(let binaryExpression):
      if binaryExpression.opToken.isAssignment {
        switch binaryExpression.lhs {
        case .variableDeclaration(let variableDeclaration):
          // Assigning and declaring a local variable
          let name = variableDeclaration.identifier.name
          // Make sure to declare variable at start of function
          addCurrentFunctionVariableDeclaration(variableDeclaration)
          return [.assignment(.identifier(name), process(binaryExpression.rhs))]

        case .identifier(let identifier):
          let name = identifier.name
          switch binaryExpression.opToken {
          case .plusEqual:
            return [.assignment(.identifier(name), .add(.identifier(name), process(binaryExpression.rhs)))]
          case .minusEqual:
            return [.assignment(.identifier(name), .subtract(.identifier(name), process(binaryExpression.rhs)))]
          case .timesEqual:
            return [.assignment(.identifier(name), .multiply(.identifier(name), process(binaryExpression.rhs)))]
          case .divideEqual:
            return [.assignment(.identifier(name), .divide(.identifier(name), process(binaryExpression.rhs)))]
          case .equal:
            return [.assignment(.identifier(name), process(binaryExpression.rhs))]
          default:
            print("Unknown assignment operator used in binary operator \(binaryExpression.opToken)")
            fatalError()
          }

        default:
            return [.assignment(process(binaryExpression.lhs), process(binaryExpression.rhs))]
        }
      }

      // Not declaring or assigning a variable
      return [.expression(process(binaryExpression))]

    case .variableDeclaration(let variableDeclaration):
      let name = variableDeclaration.identifier.name
      // Make sure to declare variable at start of function
      addCurrentFunctionVariableDeclaration(variableDeclaration)
      return []

    case .bracketedExpression(let bracketedExpression):
      return process(bracketedExpression.expression)

    case .functionCall(let functionCall):
      //TODO: Implement -> asserts -> if external call.
      // TODO: If value was used in expression, need to create a variable and have it use it.
      // Create mapping from functionName to return variable?
      return []

    default:
      return [.expression(process(expression))]
    }
  }

  // TODO: This function is absolutely vile
  private mutating func process(_ expression: Expression) -> BExpression {
    switch expression {
    case .identifier(let identifier):
      return .identifier(identifier.name)

    case .binaryExpression(let binaryExpression):
      return process(binaryExpression)

    case .bracketedExpression(let bracketedExpression):
      return process(bracketedExpression.expression)

    case .subscriptExpression(let subscriptExpression):
      return .mapRead(process(subscriptExpression.baseExpression),
                      process(subscriptExpression.indexExpression))

    case .literal(let token):
      switch token.kind {
      case .literal(let literal):
          switch literal {
          case .boolean(let booleanLiteral):
            return .boolean(booleanLiteral == Token.Kind.BooleanLiteral.`true`)

          case .decimal(let decimalLiteral):
            switch decimalLiteral {
            case .integer(let i):
              return .integer(i)
            case .real(let b, let f):
              return .real(b, f)
            }

          case .string(let string):
            // TODO: Implement strings
            print("Not implemented translating strings")
            fatalError()
          case .address(let address):
            // TODO: Implement addresses
            print("Not implemented translating addresses")
            fatalError()
          }
      default:
        print("Not implemented handling other literals")
        fatalError()
      }

    case .rawAssembly:
      print("Not implemented translating raw assembly")
      fatalError()

    case .`self`:
      print("Not translating 'self', no equivalent")
      fatalError()

      /*
      // TODO: Implement expressions
    case inoutExpression(InoutExpression)
    case attemptExpression(AttemptExpression)
    case sequence([Expression])
    case range(RangeExpression)

    // TODO:
    //case arrayLiteral(ArrayLiteral)
    //case dictionaryLiteral(DictionaryLiteral)

      */

    default:
      return .integer(0)
    }
  }

  private mutating func process(_ binaryExpression: BinaryExpression) -> BExpression {
    let lhs = binaryExpression.lhs
    let rhs = binaryExpression.rhs
    switch binaryExpression.opToken {
    case .dot:
      // TODO: Need to think carefully here -> Structs or fields (array size..)
      switch lhs {
      case .`self`:
        // TODO: What about clashing global and local variable names?
        return process(rhs)
      default:
        return process(rhs)
      }

    //TODO Handle unsafe operators
    case .plus:
      return .add(process(lhs), process(rhs))
    //case .overflowingPlus:
    case .minus:
      return .subtract(process(lhs), process(rhs))
    //case .overflowingMinus:
    case .times:
      return .multiply(process(lhs), process(rhs))
    //case .overflowingTimes:
    //case .power:
    case .divide:
      return .divide(process(lhs), process(rhs))

    // Comparisons
    case .doubleEqual:
      return .equals(process(lhs), process(rhs))
    case .notEqual:
      return .not(.equals(process(lhs), process(rhs)))
    case .lessThanOrEqual:
      return .or(.lessThan(process(lhs), process(rhs)), .equals(process(lhs), process(rhs)))
    case .greaterThanOrEqual:
      return .not(.lessThan(process(lhs), process(rhs)))
    case .or:
      return .or(process(lhs), process(rhs))
    case .and:
      return .and(process(lhs), process(rhs))

    /*
    // Assignments
    // TODO: Can nest these!
    case .equal:
    case .plusEqual:
    case .minusEqual:
    case .timesEqual:
    case .divideEqual:
      */


      /*
      //TODO: Handle
    case .at:
    case .arrow:
    case .leftArrow:
    case .comma:
    case .semicolon:
    case .doubleSlash:
    case .openAngledBracket:
    case .closeAngledBracket:

    case .dotdot:
    case .ampersand:
    case .bang:
    case .question:

    // Ranges
    case .halfOpenRange:
    case .closedRange:
      */
    default:
      break
    }

    return BExpression.add(process(lhs), process(rhs))
  }

  private mutating func addCurrentFunctionVariableDeclaration(_ vDeclaration: VariableDeclaration) {
    let name = vDeclaration.identifier.name
    let type = convertType(vDeclaration.type)
    // Declared local expressions don't have assigned expressions
    assert(vDeclaration.assignedExpression == nil)

    let bvDeclaration = BVariableDeclaration(name: name, type: type)
    if functionVariableDeclarations[currentFunction!] == nil {
      functionVariableDeclarations[currentFunction!] = []
    }
    functionVariableDeclarations[currentFunction!]!.append(bvDeclaration)
  }

  private func getStateVariable() -> String {
    return contractStateVariable[currentContract!]!
  }

  private func getStateVariableValue(_ identifier: String) -> Int {
    return contractStateVariableStates[currentContract!]![identifier]!
  }

  private func generateStateVariable() -> String {
    return "stateVariable_\(currentContract!)"
  }

  private func convertType(_ type: Type) -> BType {
    return convertType(type.rawType)
  }

  private func convertType(_ type: RawType) -> BType {
    func convertBasicType(_ bType: RawType.BasicType) -> BType {
      switch bType {
      case .address: return .userDefined("Address")
      case .int: return .int
      case .bool: return .boolean
      default:
        print("not implemented conversion for basic type: \(type)")
        fatalError()
      }
    }

    func convertStdlibType(_ sType: RawType.StdlibType) -> BType {
      switch sType {
      case .wei:
        return .userDefined("Wei") //TODO: What about assets? Make this non-primitive?
      }
    }

    switch type {
    case .basicType(let basicType):
      return convertBasicType(basicType)
    case .stdlibType(let stdlibType):
      return convertStdlibType(stdlibType)
    case .dictionaryType(let keyType, let valueType):
      return BType.map(convertType(keyType), convertType(valueType))
    case .arrayType(let type):
      return .map(.int, convertType(type))
    default:
      print("not implemented conversion for type: \(type)")
      fatalError()
    }
  }

  private func defaultValue(_ type: BType) -> BExpression {
    switch type {
    case .int: return .integer(0)
    case .real: return .real(0, 0)
    case .boolean: return .boolean(false) // TODO: Is this the default bool value?

    default:
      return .integer(0)
    }
  }
}
