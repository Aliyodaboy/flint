import AST
import Source
import Lexer
import Foundation

struct BoogieTranslator {
  // TODO: Need to parse contract invariants

  /*
  // invariants which need to hold on each function pre + post condition
  private var contractInvariants = [String]()
  */

  private let topLevelModule: TopLevelModule
  private let environment: Environment
  private var functionVariableDeclarations = [String: [BVariableDeclaration]]()
  private var functionReturnVariableName = [String: String]()
  private var currentFunction: String?
  private var currentContract: String?
  private var contractStateVariable = [String: String]()
  private var contractStateVariableStates = [String: [String: Int]]()
  private var flintProofObligationSourceLocation = [Int: SourceLocation]()

  private var contractConstructorInitialisations = [String: [BStatement]]()

  public init(topLevelModule: TopLevelModule, environment: Environment) {
    self.topLevelModule = topLevelModule
    self.environment = environment
  }

  public mutating func translate() -> (String, [Int: SourceLocation]) {
    /* for everything defined in TLM, generate Boogie representation */
    // Generate AST and print
    //TODO: Generate line mappings -> boogie to flint (for assertions)
    let boogieCode = "// Generated by flintc\n \(generateAST())"
    return (boogieCode, generateFlint2BoogieMapping(code: boogieCode))
  }

  private mutating func generateAST() -> BTopLevelProgram {
    var declarations = [BTopLevelDeclaration]()

    for case .contractDeclaration(let contractDeclaration) in topLevelModule.declarations {
      declarations += process(contractDeclaration)
    }

    for case .structDeclaration(let structDeclaration) in topLevelModule.declarations {
      declarations += process(structDeclaration)
    }

    for case .enumDeclaration(let enumDeclaration) in topLevelModule.declarations {
      declarations += process(enumDeclaration)
    }

    for case .traitDeclaration(let traitDeclaration) in topLevelModule.declarations {
      declarations += process(traitDeclaration)
    }

    for case .contractBehaviorDeclaration(let contractBehaviorDeclaration) in topLevelModule.declarations {
      declarations += process(contractBehaviorDeclaration)
    }

    return BTopLevelProgram(declarations: declarations)
  }

  private mutating func process(_ contractDeclaration: ContractDeclaration) -> [BTopLevelDeclaration] {
    currentContract = contractDeclaration.identifier.name

    var declarations = [BTopLevelDeclaration]()
    for variableDeclaration in contractDeclaration.variableDeclarations {
      let name = translateGlobalIdentifierName(variableDeclaration.identifier.name)
      let type = convertType(variableDeclaration.type)

      // Some variables require shadow variables, eg dictionaries need an array of keys
      for bvariableDeclaration in generateVariables(variableDeclaration) {
        declarations.append(.variableDeclaration(bvariableDeclaration))
      }

      // Record assignment to put in constructor procedure
      let assignedExpression = variableDeclaration.assignedExpression == nil
        ? defaultValue(type) : process(variableDeclaration.assignedExpression!).0
      if contractConstructorInitialisations[currentContract!] == nil {
        contractConstructorInitialisations[currentContract!] = []
      }
      contractConstructorInitialisations[currentContract!]!.append(
        .assignment(.identifier(name), assignedExpression)
      )
    }

    let stateVariableName = generateStateVariable()
    contractStateVariable[currentContract!] = stateVariableName
    // Declare contract state variable
    declarations.append(.variableDeclaration(BVariableDeclaration(name: stateVariableName,
                                                                  type: .int)))

    contractStateVariableStates[currentContract!] = [String: Int]()
    for typeState in contractDeclaration.states {
      contractStateVariableStates[currentContract!]![typeState.name]
        = contractStateVariableStates[currentContract!]!.count
    }

    currentContract = nil
    return declarations
  }

  private func process(_ enumDeclaration: EnumDeclaration) -> [BTopLevelDeclaration] {
    // TODO:
    return []
  }

  private func process(_ traitDeclaration: TraitDeclaration) -> [BTopLevelDeclaration] {
    // TODO:
    return []
  }

  private func process(_ structDeclaration: StructDeclaration) -> [BTopLevelDeclaration] {
    /*
    for member in structDeclaration.members {
      switch member {
      case .variableDeclaration(let variableDeclaration):
      case .functionDeclaration...
      }
    }
    */
    // TODO:
    return []
  }

  private mutating func process(_ contractBehaviorDeclaration: ContractBehaviorDeclaration) -> [BTopLevelDeclaration] {
    currentContract = contractBehaviorDeclaration.contractIdentifier.name

    // TODO: Use type states, to generate pre-conditions
    _ = contractBehaviorDeclaration.states
    // TODO: Use caller capabilities
    _ = contractBehaviorDeclaration.callerProtections
    var declarations = [BTopLevelDeclaration]()

    for member in contractBehaviorDeclaration.members {
      switch member {
      case .specialDeclaration(let specialDeclaration):
        currentFunction =
          "\(specialDeclaration.signature.specialToken)_\(contractBehaviorDeclaration.contractIdentifier.name)"
        let body = specialDeclaration.body
        let parameters = specialDeclaration.signature.parameters
        let processedBody = body.flatMap({x in process(x)})

        // Constructor
        declarations.append(.procedureDeclaration(BProcedureDeclaration(
          name: currentFunction!,
          returnType: nil,
          returnName: nil,
          parameters: parameters.map({x in process(x)}),
          preConditions: [], // TODO [BFirstOrderProperty]
          postConditions: [], // TODO [BFirstOrderProperty]
          modifies: [], // TODO [BModifiesDeclaration]
          statements: ((specialDeclaration.isInit ? contractConstructorInitialisations[currentContract!] ?? [] : [])
                       + processedBody),
          variables: functionVariableDeclarations[currentFunction!] ?? []
          )))

        currentFunction = nil

      case .functionDeclaration(let functionDeclaration):
        currentFunction =
          "\(functionDeclaration.signature.identifier.name)_\(contractBehaviorDeclaration.contractIdentifier.name)"
        let body = functionDeclaration.body
        let parameters = functionDeclaration.signature.parameters
        let name = functionDeclaration.name
        let signature = functionDeclaration.signature

        declarations.append(.procedureDeclaration(BProcedureDeclaration(
          name: "\(name)_\(contractBehaviorDeclaration.contractIdentifier.name)",
          returnType: signature.resultType == nil ? nil : convertType(signature.resultType!),
          returnName: signature.resultType == nil ? nil : generateFunctionReturnVariable(),
          parameters: parameters.map({x in process(x)}),
          preConditions: [], // TODO [BFirstOrderProperty]
          postConditions: [], // TODO [BFirstOrderProperty]
          modifies: [], // TODO [BModifiesDeclaration]
          statements: body.flatMap({x in process(x)}),
          variables: functionVariableDeclarations[currentFunction!] ?? []
          )))
        currentFunction = nil

      default:
        // TODO: Handle functionSignatureDeclaration case
        // TODO: Handle specialFunctionSignatureDeclaration case
        print("found declaration: \(member)")
      }
    }

    currentContract = nil
    return declarations
  }

  private func process(_ parameter: Parameter) -> BParameterDeclaration {
    return BParameterDeclaration(name: translateIdentifierName(parameter.identifier.name),
                                 type: convertType(parameter.type))
  }

  private mutating func process(_ statement: Statement) -> [BStatement] {
    switch statement {
    case .expression(let expression):
      // Expresson can return statements -> assignments, or assertions..
      var (bExpression, statements) = process(expression)
      switch bExpression {
      case BExpression.identifier, BExpression.mapRead, BExpression.nop:
        break
      default:
        statements.append(.expression(bExpression))
      }
      return statements

    case .returnStatement(let returnStatement):
      var statements = [BStatement]()
      if let expression = returnStatement.expression {
        let (translatedExpr, preStatements) = process(expression)
        statements += preStatements
        statements.append(.assignment(.identifier(getFunctionReturnVariable()),
                                      translatedExpr))
      }
      statements.append(.returnStatement)
      return statements

    case .becomeStatement(let becomeStatement):
      let stateVariable = getStateVariable()
      let stateValue: Int
      switch becomeStatement.expression {
      case .identifier(let identifier):
         stateValue = getStateVariableValue(identifier.name)
      default:
        print("Unknown expression in becomeStatement \(becomeStatement.expression)")
        fatalError()
      }
      return [.assignment(.identifier(stateVariable), .integer(stateValue))]

    case .ifStatement(let ifStatement):
      let (condExpr, condStmt) = process(ifStatement.condition)
      return condStmt + [
        .ifStatement(BIfStatement(condition: condExpr,
                                  trueCase: ifStatement.body.flatMap({x in process(x)}),
                                  falseCase: ifStatement.elseBody.flatMap({x in process(x)}))
        )]

    case .forStatement(let forStatement):
      let (iterableExpr, condStmt) = process(forStatement.iterable)
      //TODO: Handle iterable. Move to next item -> depends on what we are incrementing

      // if iterable is:
      //  - array
      //    - iterate through
      //  - dict
      //    - shadow keys array
      //  - range
      //    - iterate through

      addCurrentFunctionVariableDeclaration(forStatement.variable)
      return condStmt + [
        .whileStatement(BWhileStatement(
          condition: iterableExpr,
          body: forStatement.body.flatMap({x in process(x)}),
          invariants: []) // TODO: invariants
        )]

    case .emitStatement:
      // Ignore emit statements
      return []
    }
  }

  private mutating func process(_ expression: Expression) -> (BExpression, [BStatement]) {
    switch expression {
    case .variableDeclaration(let variableDeclaration):
      let name = translateIdentifierName(variableDeclaration.identifier.name)

      // Some variable types require shadow variables, eg dictionaries (array of keys)
      for declaration in generateVariables(variableDeclaration) {
        addCurrentFunctionVariableDeclaration(declaration)
      }
      return (.identifier(name), [])

    case .functionCall(let functionCall):
      let rawFunctionName = functionCall.identifier.name
      var argumentsExpressions = [BExpression]()
      var argumentsStatements = [BStatement]()
      for arg in functionCall.arguments {
        let (expr, stmts) = process(arg.expression)
        argumentsExpressions.append(expr)
        argumentsStatements += stmts
      }

      // Special case to handle assert functions
      if rawFunctionName == "assert" {
        // assert that assert function call always has one argument
        assert (argumentsExpressions.count == 1)
        let flintLine = functionCall.identifier.sourceLocation.line
        flintProofObligationSourceLocation[flintLine] = functionCall.sourceLocation
        argumentsStatements.append(.assertMarker(flintLine))
        argumentsStatements.append(.assertStatement(argumentsExpressions[0]))
        return (.nop, argumentsStatements)
      }

      let functionName = translateGlobalIdentifierName(rawFunctionName)

      //TODO: Assert that contract invariant holds?
      if false {//let btype = functionReturnType[functionName] { // TODO: Look in environment to get function return type
        // Function returns a value
        let returnValueVariable = generateFunctionReturnValueName() // Variable to hold return value
        let returnValue = BExpression.identifier(returnValueVariable)
        let functionCall = BStatement.callProcedure([returnValueVariable],
                                                     functionName,
                                                     argumentsExpressions)
        addCurrentFunctionVariableDeclaration(BVariableDeclaration(name: returnValueVariable,
                                                                   type: BType.int))//btype))
        argumentsStatements.append(functionCall)
        return (returnValue, argumentsStatements)
      } else {
        // Function doesn't return a value
        // Can assume can't be called as part of a nested expression, as it has no
        // return value -> Is this true? TODO - test
        argumentsStatements.append(.callProcedure([], functionName, argumentsExpressions))
        return (.nop, argumentsStatements)
      }

    case .identifier(let identifier):
      return (.identifier(translateIdentifierName(identifier.name)), [])

    case .binaryExpression(let binaryExpression):
      return process(binaryExpression)

    case .bracketedExpression(let bracketedExpression):
      return process(bracketedExpression.expression)

    case .subscriptExpression(let subscriptExpression):
      let (subExpr, subStmts) = process(subscriptExpression.baseExpression)
      let (indxExpr, indexStmts) = process(subscriptExpression.indexExpression)
      return (.mapRead(subExpr, indxExpr), subStmts + indexStmts)

    case .literal(let token):
      return (process(token), [])

    case .rawAssembly:
      print("Not implemented translating raw assembly")
      fatalError()

    case .`self`:
      return (.nop, [])

    case .arrayLiteral:
      //TODO:
      // Assign temp identifier empty array -> based on type
      // assign expression to corresponding index
      // return tempArray identifier

      //addCurrentFunctionVariableDeclaration(name: tempLiteralVariableName,
      //                                      type: arrayType)
      //return (.identifier(tempLiteralVariableName), assignmentStmts)
      return (.identifier("arrayLiteral"), [])

    case .dictionaryLiteral:
      //TODO:
      // Assign temp identifier empty array -> based on type
      // assign expression to corresponding index
      // return tempArray identifier
      //addCurrentFunctionVariableDeclaration(name: tempLiteralVariableName,
      //                                      type: dictionaryType)
      //return (.identifier(tempLiteralVariableName), assignmentStmts)
      return (.identifier("dictionaryLiteral"), [])

      // TODO: Implement expressions
    /*
    case .inoutExpression(let inoutExpression):
    case .attemptExpression(let attemptExpression):
    case .sequence(let expressions: [Expression]):
    case .range(let rangeExpression):
      */

    default:
      print("Not implemented translating \(expression.description)")
      fatalError()
    }
  }

  private func process(_ token: Token) -> BExpression {
    switch token.kind {
    case .literal(let literal):
      return process(literal)
    default:
      print("Not implemented handling other literals")
      fatalError()
    }
  }

  private func process(_ literal: Token.Kind.Literal) -> BExpression {
    switch literal {
    case .boolean(let booleanLiteral):
      return .boolean(booleanLiteral == Token.Kind.BooleanLiteral.`true`)

    case .decimal(let decimalLiteral):
      switch decimalLiteral {
      case .integer(let i):
        return .integer(i)
      case .real(let b, let f):
        return .real(b, f)
      }

    case .string:
      // TODO: Implement strings
      // Create const string for this literal -> const normalisedString: String;
      print("Not implemented translating strings")
      fatalError()
    case .address:
      // TODO: Implement addresses
      // Create const address -> for this literal -> const normalisedAddress: Address;
      print("Not implemented translating addresses")
      fatalError()
    }
  }

  private mutating func process(_ binaryExpression: BinaryExpression) -> (BExpression, [BStatement]) {
    let lhs = binaryExpression.lhs
    let rhs = binaryExpression.rhs
    let (rhsExpr, rhsStmts) = process(rhs)
    let (lhsExpr, lhsStmts) = process(lhs)

    switch binaryExpression.opToken {
    case .dot:
      switch lhs {
      case .`self`:
        // TODO
        // self.A, means get the A in the contract, not the local declaration

        //translateGlobalIdentifierName()
        return (rhsExpr, rhsStmts)

      // TODO: Implement for struct fields and methods (eg array size..)
      default:
        return (rhsExpr, rhsStmts)
      }

    case .equal:
      return (lhsExpr, lhsStmts + rhsStmts + [.assignment(lhsExpr, rhsExpr)])
    case .plusEqual:
      return (lhsExpr, lhsStmts + rhsStmts + [.assignment(lhsExpr, .add(lhsExpr, rhsExpr))])
    case .minusEqual:
      return (lhsExpr, lhsStmts + rhsStmts + [.assignment(lhsExpr, .subtract(lhsExpr, rhsExpr))])
    case .timesEqual:
      return (lhsExpr, lhsStmts + rhsStmts + [.assignment(lhsExpr, .multiply(lhsExpr, rhsExpr))])
    case .divideEqual:
      return (lhsExpr, lhsStmts + rhsStmts + [.assignment(lhsExpr, .divide(lhsExpr, rhsExpr))])

    case .plus:
      return (.add(lhsExpr, rhsExpr), lhsStmts + rhsStmts)
    case .minus:
      return (.subtract(lhsExpr, rhsExpr), lhsStmts + rhsStmts)
    case .times:
      return (.multiply(lhsExpr, rhsExpr), lhsStmts + rhsStmts)
    case .divide:
      return (.divide(lhsExpr, rhsExpr), lhsStmts + rhsStmts)

    //TODO Handle unsafe operators
    //case .overflowingPlus:
    //case .overflowingMinus:
    //case .overflowingTimes:

    //TODO: Handle power operator
    //case .power:

    // Comparisons
    case .doubleEqual:
      return (.equals(lhsExpr, rhsExpr), lhsStmts + rhsStmts)
    case .notEqual:
      return (.not(.equals(lhsExpr, rhsExpr)), lhsStmts + rhsStmts)
    case .openAngledBracket:
      return (.lessThan(lhsExpr, rhsExpr), lhsStmts + rhsStmts)
    case .closeAngledBracket:
      return (.greaterThan(lhsExpr, rhsExpr), lhsStmts + rhsStmts)
    case .lessThanOrEqual:
      return (.or(.lessThan(lhsExpr, rhsExpr), .equals(lhsExpr, rhsExpr)), lhsStmts + rhsStmts)
    case .greaterThanOrEqual:
      return (.not(.lessThan(lhsExpr, rhsExpr)), lhsStmts + rhsStmts)
    case .or:
      return (.or(lhsExpr, rhsExpr), lhsStmts + rhsStmts)
    case .and:
      return (.and(lhsExpr, rhsExpr), lhsStmts + rhsStmts)

      /*
      //TODO: Handle
    case .at:
    case .arrow:
    case .leftArrow:
    case .comma:
    case .semicolon:
    case .doubleSlash:
    case .dotdot:
    case .ampersand:
    case .bang:
    case .question:

    // Ranges
    case .halfOpenRange:
    case .closedRange:
      */
    default:
      print("Unknown binary operator used \(binaryExpression.opToken)")
      fatalError()
    }
  }

  private mutating func addCurrentFunctionVariableDeclaration(_ vDeclaration: VariableDeclaration) {
    let name = translateIdentifierName(vDeclaration.identifier.name)
    let type = convertType(vDeclaration.type)
    // Declared local expressions don't have assigned expressions
    assert(vDeclaration.assignedExpression == nil)

    addCurrentFunctionVariableDeclaration(BVariableDeclaration(name: name, type: type))
  }

  private mutating func addCurrentFunctionVariableDeclaration(_ bvDeclaration: BVariableDeclaration) {
    if let functionName = currentFunction {
      if functionVariableDeclarations[functionName] == nil {
        functionVariableDeclarations[functionName] = []
      }
      functionVariableDeclarations[functionName]!.append(bvDeclaration)
    } else {
      print("Error cannot add variable declaration to function: \(bvDeclaration), not currently translating a function")
      fatalError()
    }
  }

  private func generateVariables(_ variableDeclaration: VariableDeclaration) -> [BVariableDeclaration] {
    // If currently in a function, then generate name with function in it
    // If in contractDeclaration, then generate name with only contract in it
    let name: String = currentFunction == nil ?
      translateGlobalIdentifierName(variableDeclaration.identifier.name)
      : translateIdentifierName(variableDeclaration.identifier.name)

    var declarations = [BVariableDeclaration]()
    let type = convertType(variableDeclaration.type)

    // TODO: Bounded array, then create array size variable
    switch type {
    case .map(let keyType, let valueType):
      declarations.append(BVariableDeclaration(name: "keys_\(name)", type: .map(.int, keyType)))
      declarations.append(BVariableDeclaration(name: "values_\(name)", type: .map(.int, valueType)))
    default:
      break
    }

    declarations.append(BVariableDeclaration(name: name, type: type))
    return declarations
  }

  private func getStateVariable() -> String {
    if let contractName = currentContract {
      return contractStateVariable[contractName]!
    }
    print("Error cannot get contract state variable, not currently translating a contract")
    fatalError()
  }

  private func getStateVariableValue(_ identifier: String) -> Int {
    if let contractName = currentContract {
      return contractStateVariableStates[contractName]![identifier]!
    }
    print("Error cannot get contract state variable value \(identifier), not currently translating a contract")
    fatalError()
  }

  private func generateStateVariable() -> String {
    if let contractName = currentContract {
      return "stateVariable_\(contractName)"
    }
    print("Error cannot generate contract state variable, not currently translating a contract")
    fatalError()
  }

  private mutating func generateFunctionReturnVariable() -> String {
    if let functionName = currentFunction {
      // TODO: Check against all declared variables in the function
      let returnVariable = "result_variable_\(functionName)"
      functionReturnVariableName[functionName] = returnVariable
      return returnVariable
    }
    print("Cannot generate function return variable, not currently in a function")
    fatalError()
  }

  private func getFunctionReturnVariable() -> String {
    if let functionName = currentFunction {
      if let returnVariable = functionReturnVariableName[functionName] {
        return returnVariable
      }
      print("Could not find return variables for function \(functionName)")
      fatalError()
    }
    print("Could not find return variable not currently in a function")
    fatalError()
  }

  private mutating func generateFunctionReturnValueName() -> String {
    //TODO: Check against all declared variables in the function
    return "testTempVariable"
  }

  private func translateIdentifierName(_ name: String) -> String {
    if let functionName = currentFunction {
      // Function name already has contract scope (eg. funcA_ContractA
      return name + "_\(functionName)"
    }
    print("Error cannot translate identifier: \(name), not translating contract")
    fatalError()
  }

  private func translateGlobalIdentifierName(_ name: String) -> String {
    if let contractName = currentContract {
      return name + "_\(contractName)"
    }
    print("Error cannot translate global identifier: \(name), not translating contract")
    fatalError()
  }

  private func convertType(_ type: Type) -> BType {
    return convertType(type.rawType)
  }

  private func convertType(_ type: RawType) -> BType {
    func convertBasicType(_ bType: RawType.BasicType) -> BType {
      switch bType {
      case .address: return .userDefined("Address")
      case .int: return .int
      case .bool: return .boolean
      default:
        print("not implemented conversion for basic type: \(type)")
        fatalError()
      }
    }

    func convertStdlibType(_ sType: RawType.StdlibType) -> BType {
      switch sType {
      case .wei:
        return .userDefined("Wei") //TODO: What about assets? Make this non-primitive?
      }
    }

    switch type {
    case .basicType(let basicType):
      return convertBasicType(basicType)
    case .stdlibType(let stdlibType):
      return convertStdlibType(stdlibType)
    case .dictionaryType(let keyType, let valueType):
      return BType.map(convertType(keyType), convertType(valueType))
    case .arrayType(let type):
      return .map(.int, convertType(type))
    default:
      print("not implemented conversion for type: \(type)")
      fatalError()
    }
  }

  private func defaultValue(_ type: BType) -> BExpression {
    switch type {
    case .int: return .integer(0)
    case .real: return .real(0, 0)
    case .boolean: return .boolean(false) // TODO: Is this the default bool value?

    default:
      return .integer(0)
    }
  }

  private func generateFlint2BoogieMapping(code: String) -> [Int: SourceLocation] {
    var mapping = [Int: SourceLocation]()

    let lines = code.trimmingCharacters(in: .whitespacesAndNewlines)
                               .components(separatedBy: "\n")
    var boogieLine = 1 // Boogie starts counting lines from 1
    for line in lines {
      // Pre increment because assert markers precede asserts
      boogieLine += 1

      // Look for ASSERT markers
      let matches = line.groups(for: "//#ASSERT# ([0-9]+)")
      if matches.count == 1 {
        // Extract line number
        mapping[boogieLine] = flintProofObligationSourceLocation[Int(matches[0][1])!]!
      }
    }
    return mapping
  }
}
